[
    {
        "id": 3,
        "title": "Print Two Numbers",
        "description": " Write a program to read two integers a and b, print b first in a line, then print a in another line.",
        "inputFormat": " There are two lines in the input. The first line has the integer a, and the second line has the integer b.",
        "outputFormat": " There are two lines in the output. The first line has the integer b, and the second line has the integer a.",
        "sampleInput": [
            "1\n2\n"
        ],
        "sampleOutput": [
            "2\n1\n"
        ],
        "hint": "",
        "AC": 3059,
        "WA": 1459
    },
    {
        "id": 4,
        "title": "Add Three Numbers",
        "description": " Write a program to read three integers a, b, and c, then print their sum.",
        "inputFormat": " There are three lines in the input. The first line has the integer a, the second line has the integer b, and the third line has the integer c.",
        "outputFormat": " There is one line in the output. The line has the sum of a, b, and c.",
        "sampleInput": [
            "1\n2\n3\n"
        ],
        "sampleOutput": [
            "6\n"
        ],
        "hint": "",
        "AC": 1750,
        "WA": 327
    },
    {
        "id": 5,
        "title": "Surface Area and Volume",
        "description": " Write a program to read three numbers as the height, width, and depth of a cuboid, then print its surface area in a line, then its volume in a line.",
        "inputFormat": " There are three lines in the input. The first line has the height h, the second line has the width w, and the third line has the depth d.",
        "outputFormat": " There are two lines in the output. The first line has the surface area, and the second line has the volume.",
        "sampleInput": [
            "1\n2\n3\n"
        ],
        "sampleOutput": [
            "22\n6\n"
        ],
        "hint": "",
        "AC": 1616,
        "WA": 425
    },
    {
        "id": 6,
        "title": "Print Three Digits",
        "description": " Write a program to read a number x between 100 and 999, then print the first, the second and the third digit of x. Every digit is in one line.",
        "inputFormat": " There is one line in the input. The line has a number x.",
        "outputFormat": " There are three lines in the output. The first line has the first digit of x; the second line has the second digit, then the third line has the third digit.",
        "sampleInput": [
            "123\n"
        ],
        "sampleOutput": [
            "1\n2\n3\n"
        ],
        "hint": "",
        "AC": 1649,
        "WA": 348
    },
    {
        "id": 7,
        "title": "3, 5, and 7",
        "description": " Write a program to print 0 if the input x is a multiple of 3, and is a multiple of 5, but is not a multiple of 7. Otherwise, print 1. 如果 x 是 3 和 5 的倍數且不是 7 的倍數，在螢幕上輸出 0。其他情況輸出 1。",
        "inputFormat": " There is one line in the input. The line has a number x.",
        "outputFormat": " There is one line in the output. The line has 0 if the input x is a multiple of 3, and a multiple of 5, but not a multiple of 7. Otherwise, the output is 1.",
        "sampleInput": [
            "15\n",
            "105\n"
        ],
        "sampleOutput": [
            "0\n",
            "1\n"
        ],
        "hint": "",
        "AC": 1577,
        "WA": 667
    },
    {
        "id": 8,
        "title": "Triangle Length",
        "description": " Write a program to print 1 if the three positive integers a, b, and c are valid lengths of a triangle; print 0 otherwise. We can verify the condition by assuring that all a, b, and c are positive, and the sum of any two of them is greater than the third. 給三個整數 a,;b,;c 分別代表三角形的邊長。如果能拼成一個三角形，輸出 1，反之輸出 0。判斷三角形是否合法：任兩個邊長和大於第三邊。",
        "inputFormat": " There are three lines in the input. The first line has the integer a, the second line has the integer b, and the third line has the integer c.",
        "outputFormat": " There is one line in the output. The line has 1 if the lengths are valid, 0 otherwise.",
        "sampleInput": [
            "1\n2\n3\n",
            "2\n4\n3\n"
        ],
        "sampleOutput": [
            "0\n",
            "1\n"
        ],
        "hint": "",
        "AC": 1495,
        "WA": 443
    },
    {
        "id": 9,
        "title": "Score of an Integer",
        "description": " Write a program to compute a score for an integer x. If x is zero or negative, the score is −100. Otherwise, we start with 0. If the x is a multiple of 3, add 3 to the score. After that, if x is a multiple of 5, add 5 to the score. After that if x is between 100 and 200(inclusive), add 50 to the score, else subtract 50 from the score. Now print the score.",
        "inputFormat": " There is one line in the input. The line has the integer x.",
        "outputFormat": " There is one line in the output. The line has a score of x.",
        "sampleInput": [
            "-10\n",
            "15\n"
        ],
        "sampleOutput": [
            "-100\n",
            "-42\n"
        ],
        "hint": "",
        "AC": 1529,
        "WA": 1424
    },
    {
        "id": 10,
        "title": "Power",
        "description": " Write a program to compute the i-th power of n, where n is an integer, and i is a positive integer from 1 to 5 inclusively.",
        "inputFormat": " There are two lines in the input. The first line has the integer n. The second line has the integer i.",
        "outputFormat": " There are one line in the output. The line has the i-th power of n.",
        "sampleInput": [
            "-2\n2\n",
            "-4\n1\n"
        ],
        "sampleOutput": [
            "4\n",
            "-4\n"
        ],
        "hint": "",
        "AC": 1374,
        "WA": 397
    },
    {
        "id": 12,
        "title": "Up and Down",
        "description": " Write a program to read a positive integer n, then print a sequence of 2n−1 integers from 1 to n, and then from n−1 to 1.",
        "inputFormat": " There is one line in the input. The first line has the integer n.",
        "outputFormat": " There are 2n−1 lines in the output, according to the description.",
        "sampleInput": [
            "5\n"
        ],
        "sampleOutput": [
            "1\n2\n3\n4\n5\n4\n3\n2\n1\n"
        ],
        "hint": "",
        "AC": 1301,
        "WA": 213
    },
    {
        "id": 13,
        "title": "Print a Repeated Pattern",
        "description": " Write a program to read a positive integer n, then go through n phases. During the i-th phase, the program will print an integer sequence from 1 to i.",
        "inputFormat": " There is one line in the input. The first line has the integer n.",
        "outputFormat": " There is one line in the output according to the description.",
        "sampleInput": [
            "5\n"
        ],
        "sampleOutput": [
            "112123123412345\n"
        ],
        "hint": "",
        "AC": 1292,
        "WA": 230
    },
    {
        "id": 14,
        "title": "Print the Sequence Backward",
        "description": " Write a program to read a positive integer n and a sequence of n intergers, then print the sequence reversely. Limits n is no more than 1000.",
        "inputFormat": " There are two lines in the input. The first line has the integer n. The line has n integers.",
        "outputFormat": " There are one lines in the output, according to the description.",
        "sampleInput": [
            "5\n1 4 8 9 10\n"
        ],
        "sampleOutput": [
            "10 9 8 4 1\n特別注意\n若在行尾輸出 多餘的空白字元，你將會得到 Wrong Answer\n"
        ],
        "hint": "",
        "AC": 1204,
        "WA": 1694
    },
    {
        "id": 15,
        "title": "Print Backward to 1",
        "description": " Write a program to read a positive integer n and then print n backward to 1.",
        "inputFormat": " There is one line in the input. The first line has the integer n.",
        "outputFormat": " There are n lines in the output, according to the description.",
        "sampleInput": [
            "5\n"
        ],
        "sampleOutput": [
            "5\n4\n3\n2\n1\n"
        ],
        "hint": "",
        "AC": 1360,
        "WA": 235
    },
    {
        "id": 16,
        "title": "Even and Odd",
        "description": " Write a program to read a positive integer n and a sequence of n positive integers, then print the sequence in 2 lines. The first line is for odd numbers, and the second line is for even numbers. Limits n is no more than 1000.",
        "inputFormat": " There are two lines in the input. The first line has the integer n. The second line has the n positive integers.",
        "outputFormat": " There are two lines in the output, according to the description.",
        "sampleInput": [
            "5\n3 6 7 9 20\n"
        ],
        "sampleOutput": [
            "3 7 9\n6 20\n特別注意\n若在行尾輸出 多餘的空白字元，你將會得到 Wrong Answer\n"
        ],
        "hint": "",
        "AC": 1159,
        "WA": 1301
    },
    {
        "id": 17,
        "title": "Column Average",
        "description": " Write a program to read the number of rows (r) and columns (c) of a two-dimensional integer array first, then read the array elements row by row. Finally print the average (in integer) of every column. Limits Both r and c are no more than 100.",
        "inputFormat": " There are r+1 lines in the input. The first line has r and c. Each of the next r lines has c integers as a row in the matrix.",
        "outputFormat": " There are c lines in the output. The i-th line has the average of the i-th column.",
        "sampleInput": [
            "2 3\n1 2 3\n4 5 6\n"
        ],
        "sampleOutput": [
            "2\n3\n4\n"
        ],
        "hint": "",
        "AC": 1087,
        "WA": 284
    },
    {
        "id": 18,
        "title": "Larger than Neighbors",
        "description": " Write a program to read the number of rows (r) and columns (c) of a two-dimensional integer array, then read the array elements row by row. Finally print the elements that are greater than all of its neighbors. Note that an element can have at most 4 neighbors. If there are multiple such elements, print them in the order of row by row, column by column. 讀入一個 r 行 c 列的二維整數陣列，找到那些格子上的數字皆大於它的鄰近格子上的數字，鄰近只有限制在它的上下左右四格。如果有多個答案，從上而下、由左而右依序印出。 Limits Both r and c are no more than 100.",
        "inputFormat": " There are r+1 lines in the input. The first line has r and c. Each of the next r lines has c integers as a row in the matrix.",
        "outputFormat": " There are k lines in the output, where k is the number of elements that are larger than its neighbors.",
        "sampleInput": [
            "2 3\n7 8 3\n4 5 6\n"
        ],
        "sampleOutput": [
            "8\n6\n"
        ],
        "hint": "",
        "AC": 1066,
        "WA": 1649
    },
    {
        "id": 21,
        "title": "Maximum in Matrix",
        "description": " Write a function max to find the largest number in a 5 by 5 integer array. The prototype of max is as follows. int max(int array[5][5]); The main program is as follows.#include <stdio.h>#include \"max.h\"int main() {int i, j;int array[5][5];for (i = 0; i < 5; i++)for (j = 0; j < 5; j++)scanf(\"%d\", &(array[i][j]));printf(\"%d\\n\", max(array));return 0;}",
        "inputFormat": " There are five lines in the input. Each line has five integers.",
        "outputFormat": " There is one line in the output. The line has the maximum value in the matrix.",
        "sampleInput": [
            "1 2 3 4 5\n7 -7 7 7 7\n8 9 -10 11 2\n45 8 9 45 3\n0 0 0 0 0\n"
        ],
        "sampleOutput": [
            "45\nCompile\nCommand Line\ngcc main.c max.c -std=c99\nDev-C++\n設定編譯參數 Tools > Compiler Options > Add the following commands when calling the linker > -static-libgcc -std=c99 max.c\n回到 main.c 執行編譯 F11\n"
        ],
        "hint": "max.h\n打上 function header 以及相關的設定。\nint max(int array[5][5]);\nmax.c\n撰寫程式碼後對應上傳。\n#include \"max.h\"\nint max(int array[5][5]) {\n    /* add your code */\n}\nmain.c\n這個檔案無法更改也無須上傳。\n#include <stdio.h>\n#include \"max.h\"\n int main() {\n    int i, j;\n    int array[5][5];\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 5; j++)\n              scanf(\"%d\", &(array[i][j]));\n      printf(\"%d\\n\", max(array));\n    return 0;\n}\n",
        "AC": 1045,
        "WA": 852
    },
    {
        "id": 22,
        "title": "Negative and Positive",
        "description": " Write a function posneg to find the number of positive and negative integers in a 5 by 5 integer array. The prototype of posneg is as follows.1 void posneg(int array[5][5], int result[2]); The number of negative integers should be place in result[0], and the number of positive integers should be place in result[1]. You only need to write the function and we will use a main program to test the correctness of your function. The main program is as follows.123456789101112131415#include <stdio.h>#include \"posneg.h\" int main() {int i, j;int array[5][5];int result[2];for (i = 0; i < 5; i++)for (j = 0; j < 5; j++)scanf(\"%d\", &array[i][j]);posneg(array, result);printf(\"%d\\n\", result[0]);printf(\"%d\\n\", result[1]);return 0;}",
        "inputFormat": " There are five lines in the input. Each line has five integers.",
        "outputFormat": " There are two lines in the output. The first line has the number of negative integers, and the second line has the number of positive integers in the matrix.",
        "sampleInput": [
            "0 2 3 4 5\n7 -7 7 7 7\n8 9 -10 11 2\n45 8 9 45 3\n0 0 0 0 0\n"
        ],
        "sampleOutput": [
            "2\n17\n"
        ],
        "hint": "",
        "AC": 956,
        "WA": 996
    },
    {
        "id": 23,
        "title": "Maximum in Pointer Array",
        "description": " Write a function that finds the maximum value pointed by elements of a pointer array.1 int max(int *iptr[], int n); This function returns the maximum integer pointed by the pointers in the array iptr. Note that each element in iptr is a pointer to an integer. The main program is as follows.123456789101112131415#include <stdio.h>#include \"max.h\"int main() {int n, i;int array[100];int *iptr[100];scanf(\"%d\", &n);for (i = 0; i < n; i++) {scanf(\"%d\", &(array[(i + 3) % n]));iptr[i] = &(array[(i + 3) % n]);}printf(\"%d\\n\", max(iptr, n));return 0;} Limits n≤100",
        "inputFormat": " There are two lines in the input. The first line has n. The second line has n integers.",
        "outputFormat": " There is one lines in the output. The first line has the maximum integer as in the description.",
        "sampleInput": [
            "5\n0 20 -3 4 5\n"
        ],
        "sampleOutput": [
            "20\n"
        ],
        "hint": "",
        "AC": 1057,
        "WA": 680
    },
    {
        "id": 24,
        "title": "Vowel, Consonant, and Digit",
        "description": " Write a program that counts the number of digits, letters, vowels, and consonants in a string s. 計算字串中數字、字母、母音和子音的數量。 Limits The length of string s is no more than 100.",
        "inputFormat": " There is one line in the input. The first line has the string s.",
        "outputFormat": " There is one line in the output. The first line has the four numbers as in the description.",
        "sampleInput": [
            "string_123\n"
        ],
        "sampleOutput": [
            "3 6 1 5\n"
        ],
        "hint": "",
        "AC": 835,
        "WA": 583
    },
    {
        "id": 27,
        "title": "Surface Area and Volume of a Box",
        "description": " Write a program to compute the surface area and the volume of this box. p27 the box is solid and is pushed inward from six sides 中間為實心, 六面向內凹",
        "inputFormat": " There are five lines in the input for a,b,c,d, and e, respectively.",
        "outputFormat": " There are two lines in the output. The first line has the surface area, and the second line has the volume of the box.",
        "sampleInput": [
            "6\n8\n10\n1\n2\n"
        ],
        "sampleOutput": [
            "472\n392\nSample\n"
        ],
        "hint": "",
        "AC": 1441,
        "WA": 816
    },
    {
        "id": 28,
        "title": "Sum of Squares with Recursion",
        "description": " Write a program to compute the sum of squares from 1 to n with a recursive function. You should NOT use loops. Limits n is positive and no more than 1000.",
        "inputFormat": " There are one line in the input. The first line has n.",
        "outputFormat": " There are one lines in the output. The first line has the sum of squares from 1 to n.",
        "sampleInput": [
            "5\n"
        ],
        "sampleOutput": [
            "55\n"
        ],
        "hint": "",
        "AC": 1104,
        "WA": 193
    },
    {
        "id": 29,
        "title": "From One Corner to Another",
        "description": " Write a program to compute the number of ways to go from the lower left corner of a matrix to upper right corner. The matrix has r rows and c columns. You can only move one cell to another cell, and only to the right or to the top. Please compute the number of ways you can go. Note that you are strongly encouraged to think in \"recursion\" to solve this problem. Limits Both r and c are no more than 12.",
        "inputFormat": " There are one line in the input. The first line has r and c.",
        "outputFormat": " There are one lines in the output. The first line has the number of ways as in the description.",
        "sampleInput": [
            "4 3\n"
        ],
        "sampleOutput": [
            "10\n"
        ],
        "hint": "",
        "AC": 795,
        "WA": 320
    },
    {
        "id": 30,
        "title": "From One Corner to Another with Obstacles",
        "description": " Write a program to compute the number of ways to go from the lower left corner of a matrix to upper right corner. The matrix has r rows and c columns. You can only move one cell to another cell, and only to the right or to the top. Also there are obstacles in the matrix and you cannot go into any cell that is obstacle . Please compute the number of ways you can go. Note that you are strongly suggested to think in \"recursion\" to solve this problem. Limits Both r and c are no more than 12.",
        "inputFormat": " There are r+1 lines in the input. The first line has r and c. The next r lines have the status of the matrix. A 1 indicates a cell you can go through, and a 0 is an obstacle. Both the lower left and upper right corners are 1's.",
        "outputFormat": "",
        "sampleInput": [
            "8 3\n1 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n0 0 1\n1 1 1\n1 1 1\n"
        ],
        "sampleOutput": [
            "3\n"
        ],
        "hint": "",
        "AC": 662,
        "WA": 312
    },
    {
        "id": 32,
        "title": "Longest Double Palindrome",
        "description": " We define a palindrome as a sequence of at least one integer that reads the same either forward or backward. For example 1 3 5 3 1 and 1 2 2 1 are both palindromes. To the extreme case 1 is also a palindrome. We also define a double palindrome as the concatenation of two palindromes. For example 1 3 5 3 1 1 2 2 1 is a double palindrome. To the extreme case 1 3 5 3 1 1 is also a double palindromes. Now given a sequence of at least two integers, please find the longest double palindrome. If there are multiple longest double palindromes, print the one that appears last . Limits The number of integers in the given sequence is no more than 100.",
        "inputFormat": " There is one line in the input. The first line has the integers from which we want to find the longest double palindrome.",
        "outputFormat": " There is one lines in the output. The first line has all the integers of the longest double palindrome. number of ways as in the description.",
        "sampleInput": [
            "7 1 3 5 3 1 1\n"
        ],
        "sampleOutput": [
            "1 3 5 3 1 1\nSpecial Thanks\n感謝 B05902052 劉家維 同學增加測資\n"
        ],
        "hint": "",
        "AC": 634,
        "WA": 2287
    },
    {
        "id": 33,
        "title": "Intersections",
        "description": " Write a function to determine the number and types of intersections in a city. We use a n by n integer array to represent a city. A one in the array indicates a road, and a zero in the array indicates a building. There are four kinds of intersection of roads. A cell is an intersection if it is one, and all of its four neighbors are also one. A cell is a T-junction if it is 1 and exactly three of its neighbors are 1. A cell is a turn if it is 1 and exactly two of its neighbors are 1, and these two neighbors do not form a straight line that goes through the cell. A cell is a dead end if it is 1, and exactly one of its neighbors is 1. Now given the matrix, please compute the number of intersections, T-junctions, turns and dead ends. Limits n is no more than 100.",
        "inputFormat": " There are n+1 lines in the input. The first line has n. Each of the next lines has n integers. These integers are either 0 or 1.",
        "outputFormat": " There are four lines in the output. These four lines has the number of intersections, T-junctions, turns and dead ends, respectively.",
        "sampleInput": [
            "5\n1 1 1 1 1\n1 0 1 0 1\n1 1 1 1 1\n1 0 1 0 1\n1 1 1 0 1\n"
        ],
        "sampleOutput": [
            "1\n3\n4\n1\n"
        ],
        "hint": "",
        "AC": 1089,
        "WA": 899
    },
    {
        "id": 36,
        "title": "Calender",
        "description": " Write a program to print a calendar. You will have a year, a month, and the day of the first of the month. Then you need to print a calendar for that month. Note that you need to determine if the given year is a leap year when it is February.",
        "inputFormat": " The input has three numbers: year, month, and the day of the first day of that month. For example, if you have 2007 9 6, it means you need to print out a calendar of September 2007, with the additional information that the first day of September is a Saturday. If the day is 0, it means Sunday. We ensure that the year is between 1000 and 3000 inclusively.",
        "outputFormat": " The output is a calendar of that month. First line is Su Mo Tu We Th Fr Sa\\n to indicate the days. Then every number will be printed as %3d -- the 3 indicates the width of the number, and the numbers are enclosed by two =====================\\n. Note that you cannot put trailing spaces at the end of each line, nor put extra \\n at the end of the output. Also, note that if the input is not valid, such as 2007 13 9, print an invalid\\n.",
        "sampleInput": [
            "2007 9 6\n",
            "2007 13 9\n"
        ],
        "sampleOutput": [
            "// 請忽略這一行，只是為了下一行對齊得格式，內部問題尚未解決。\n Su Mo Tu We Th Fr Sa\n=====================\n                    1\n  2  3  4  5  6  7  8\n  9 10 11 12 13 14 15\n 16 17 18 19 20 21 22\n 23 24 25 26 27 28 29\n 30\n=====================\n",
            "invalid\nC-string representation\n\" Su Mo Tu We Th Fr Sa\\n\"\n\"=====================\\n\"\n\"                    1\\n\"\n\"  2  3  4  5  6  7  8\\n\"\n\"  9 10 11 12 13 14 15\\n\"\n\" 16 17 18 19 20 21 22\\n\"\n\" 23 24 25 26 27 28 29\\n\"\n\" 30\\n\"\n\"=====================\\n\"\n"
        ],
        "hint": "",
        "AC": 913,
        "WA": 2366
    },
    {
        "id": 37,
        "title": "Metal value",
        "description": " Write a function to determine the value of a metal block. The function prototype is as follows.1 int value(int type, int width, int height, int length); The value of a metal block is determined by its type, width, height, and length. We have six types of metals: gold, silver, copper, lead, iron, and titanium. The unit price of these metals are 30,10,4,5,3,9 respectively. A block must be cut into cubes of the same dimension before it can be sold, and no material should be left after cutting. For example, a 4 by 8 by 2 block can only be sold in 2 by 2 by 2 or 1 by 1 by 1 cubes. However, the price of a cubic is equal to the square of its volume multiplied by the unit price. As a result, the price of a 2 by 2 by 2 gold cubic is 8×8×30=1920, and the maximum value of a 4 by 8 by 2 gold block is therefore 1920×8=15360. Now given the type, width, height, and length of a block, determine its maximum value. Input The type parameter indicates the type of the metal block. If the type is 79, then the metal is gold. The rest are 47,29,82,26,22, for silver, copper, lead, iron, and titanium. The width, height, and length are the dimensions of the block. Output You need to check the input type. If the input type is not a valid metal code, you must return -1. Then you need to check the dimension. The width, height, and length all fit into an int. However, if any of the three dimension is zero or negative, your function must return -2. Otherwise return the maximum value of this metal block. We guarantee that the answer can be stored in an int.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "value(79, 4, 8, 2)\n",
            "value(100, -4, 8, 2)\n",
            "value(79, 0, 8, 2)\n"
        ],
        "sampleOutput": [
            "15360\n",
            "-1\n",
            "-2\nNotes\nYou only need to submit the function. No main program is necessary because TA will write it to test your function. The judge program will call your value() function and pass the four parameters, then read the result through its return value, so it's no need to read input data or output any messages in the value() function. Note that you cannot use array or pointer in this homework. Everything needs to be done in simple variables.\n"
        ],
        "hint": "",
        "AC": 704,
        "WA": 1340
    },
    {
        "id": 38,
        "title": "Witchcraft",
        "description": " Write a program to help a witch find out the correct composition of a secret lotion. The witch has three kinds of ingredients: alligator legs, bat eyes, and cat skulls, which we will refer to as a, b, and c. These three ingredients has three different levels of magic power, which we will refer to as A, B, and C respectively. If we put just the right amount of these ingredients together so that the sum of their magic power is exactly D, then we will be able to make the secret lotion. If we cannot put together just the right amount of magic power, we cannot make the lotion. Now given the the amounts of a, b, and c, determine if the witch can make the lotion. Input Each input has N input cases, which appears first in the input. The next N lines each is an input case. Each input case is a line of 7 integers. The first number is the amount of magic power desired (D), and the next three numbers are the units of supply of the three ingredients the witch has (a,b,c), and the last three numbers are the levels of magic power of these three ingredients (A,B,C). All the numbers are non-negative integers and can be stored in int. Output The output has N lines, each for a input case. If the witch is able to make the lotion using the supplies she has, please output \"yes\", otherwise output \"no\".",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "2\n1134 100 100 100 7 13 17\n1134 4 5 6 100 200 300\n"
        ],
        "sampleOutput": [
            "yes\nno\nNotes\nNote that you cannot use array or pointer in this homework. Everything needs to be done in simple variables. We strongly encourage you to use the recursion method to solve this problem.\n"
        ],
        "hint": "",
        "AC": 925,
        "WA": 2289
    },
    {
        "id": 44,
        "title": "Library Fine",
        "description": " Write a program to compute library fine. You will be given two .h files. The first is a book.h.1234567891011121314#ifndef BOOK_H#define BOOK_Henum Type {NOVEL, COMICS, MANUAL, TEXTBOOK};struct Book {char title[128];enum Type type;char ISBN[128];char authors[128];unsigned int importance;};#endif You will also be given a date.h.12345678910#ifndef DATE_H#define DATE_Hstruct Date {unsigned int year;unsigned int month;unsigned int day;};#endif Your function has the following prototype.1234#include \"book.h\"#include \"date.h\"unsigned int library_fine(struct Book book, struct Date date_borrowed, struct Date date_returned); Now you need to write a function that when given a book, a borrowed_date, and a returned_date, determines whether the book is overdue. If it is, you need to compute the fine. First you need to determine if the book is overdue. For this you need the \"type\" information. For NOVEL the maximum allowed period for borrowing a book is 90 days. For COMICS, MANUAL, TEXTBOOK, it is 10, 100, and 5 days respectively. Note that if you borrowed a book on 2007/11/14, and returned it on 2007/12/3, then you'd borrowed it for 20 days. Even if you borrowed and return a book at the same day, it is counted as one day. If you borrowed a NOVEL for 100 days, then it is 10 days overdue. It is guaranteed that the returned date will not be earlier than the borrowed date, and the year is between 1000 and 3000 inclusively. After you have determined whether a book is overdue, next you need to determine the fine. The fine is determined by two factors -- how many days are overdue and the importance of the book. Unfortunately the importance of a book is encoded in an unsigned integer in a very strange way. The importance value contains exactly two '1'-bits in its binary representation, and the importance factor is the distance between the two '1'-bits, i.e. the number of '0'-bits between them. The fine is equal to the product of the importance factor and the day of overdue. For example, if the importance is 17 (whose binary representation is 00000000000000000000000000010001) and the book is overdue for 10 days, then the library fine is 30. 每一本書都有其預定的出租時間，若在規定時間內歸還，則不算任何費用。如小說 NOVEL 在 90 天內 (含) 不計算任何費用，同理漫畫 COMIC 10 天、操作說明書 MANUAL 100 天、教科書 TEXTBOOK 5 天。如果超出規定時間，則需要繳交額外的罰款，每晚一天就必須多付 X 元，X 取決於 importance 轉成二進制的兩個 1-bit 位置距離。 給定書籍資訊、借出日期 borrowed_date 和歸還日期 returned_date，請撰寫一個函數計算出租費用。 Notes You only need to submit your library_fine function. The judge system would use its own main function to test your program. You may use the following program to test your program:123456789101112131415161718192021222324#include <stdio.h>#include \"book.h\"#include \"date.h\"unsigned int library_fine(struct Book book, struct Date date_borrowed, struct Date date_returned);int main(){struct Book book = {\"Neon Genesis Evangelion\",COMICS,\"978-159-116-400-5\",\"Yoshiyuki Sadamoto\",17};struct Date date_borrowed, date_returned;date_borrowed.year  = 2007;date_borrowed.month = 11;date_borrowed.day   = 14;date_returned.year  = 2007;date_returned.month = 12;date_returned.day   = 3;printf(\"The fine is $%d.\\n\", library_fine(book, date_borrowed, date_returned));return 0;}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 423,
        "WA": 1508
    },
    {
        "id": 46,
        "title": "Play with Words",
        "description": " Write a program to play with words. Your program should support the following commands. insert left x Insert character x at the beginning of a word. insert right x Insert a character x at the end of a word. insert k x Insert character x as the k-th character of this word. delete left Delete a character at the beginning of a word. delete right Delete a character at the end of a word. delete k Delete the k-th character from the word. Where x is a character other than spaces, and k is a number starting from 1. Initially there is nothing in this word, and after the following command the word should be bbaac. command word insert left a a insert left a aa insert left b baa insert right a baaa insert right c baaac insert left b bbaaac delete right bbaaa insert 4 c bbacaa delete 5 bbaca delete 4 bbaa insert 5 c bbaac Input The input data contains a sequence of commands described above. All commands are valid. For example, if your program receives a delete 5 command, we ensure that the word would has at least 5 characters for now. Output After processing the input commands, Your program should find out all of the longest consecutive sequence with the same character from left to right and output the character of each sequence in order, then output the length of the sequences at the end. All data should be separated by a single space.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "insert left a\ninsert left a\ninsert left b\ninsert right a\ninsert right c\ninsert left b\ndelete right\ninsert 4 c\ndelete 5\ndelete 4\ninsert 5 c\n"
        ],
        "sampleOutput": [
            "b a 2\n"
        ],
        "hint": "由於 C2015 回報測資太難，測資難度已經刪減。對於 N>50000\n的處理方式，可以參考解答 Solution 頁面。\n",
        "AC": 523,
        "WA": 2673
    },
    {
        "id": 47,
        "title": "Play with Words, Too",
        "description": " Write a program (again) to play with words. Your program should support the following commands. insert left x n Insert n characters of x at the beginning of a word. insert right x n Insert n characters of x at the end of a word. insert k x n Insert n characters of x so that the first of them will become the k-th character of this word. print Print the current content of the word in the following format: if the word is gooooooooooooooooooooooooooogle, you should print g 1 o 27 g 1 l 1 e 1 $. In other words, you should encode all consecutive sequences with the same character into character-length pairs, then print a dollar sign to indicate the end of the word. Where x is a alphanumeric character and both n and k are positive integers. Note that you need to implement this word as a binary tree, otherwise it it very likely that you will run out of time because you need to run through the data structure in order to find the correct location for insertion. You may want to store the number of characters in a node, as well as the number of characters in the sub-tree to speed thing up. Input The input data contains a sequence of commands described above. You may assume that all commands are valid. That is, k would not exceed the current length of the word plus 1. The total length of the word would less then 2147483647. Output You should output the content of the word in the compressed format described above whenever you read the print command.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "print\ninsert left g 2\ninsert right e 1\ninsert 3 l 1\ninsert 2 o 2\nprint\ninsert 4 o 25\nprint\n"
        ],
        "sampleOutput": [
            "$\ng 1 o 2 g 1 l 1 e 1 $\ng 1 o 27 g 1 l 1 e 1 $\n"
        ],
        "hint": "",
        "AC": 175,
        "WA": 1270
    },
    {
        "id": 49,
        "title": "Sum, Maximum and Minimum",
        "description": " Given a set of N numbers, please find the following according to the remainder when divided by another positive number m. The sum of these numbers The maximum of these numbers The minimum of these numbers For example, when m=2 then you need to find the sums of all odd and the sum of all even numbers, the maximum of even numbers and the maximum of all odd numbers, and the minimum of all odd numbers and the minimum of all even numbers. It is guaranteed that there will be at least one number corresponding to all the possible m(from 0 to m−1) remainders.",
        "inputFormat": " The first line of the input data consists of two integers N and m, where 0≤N≤10000 and 1≤m≤1000. The next line contains N non-negative integers to be processed, and each integer is less then or equal to 10000.",
        "outputFormat": " You should output m lines. The i'th line must consists of three numbers, which are the sum, maximum and minimum of those numbers whose remainders are i−1 modulo m respectively.",
        "sampleInput": [
            "6 3\n0 1 2 4 7 14\n"
        ],
        "sampleOutput": [
            "0 0 0\n12 7 1\n16 14 2\n"
        ],
        "hint": "",
        "AC": 849,
        "WA": 712
    },
    {
        "id": 50,
        "title": "Overlap Area",
        "description": " Given three rectangles whose sides are parallel to either x-axis or y-axis, please compute the area of the shape that is covered by at least one of these three rectangles. The three rectangles can overlap in any way you can imagine, however, this is as the same as computing the union of three sets. 給予 3 個平行兩座標軸的矩形，請計算至少被其中一個矩形覆蓋的面積，相當於計算聯集後的面積。",
        "inputFormat": " There are 3 lines in the input data. In each line there are 4 integers l,b,r,t representing a rectangle, where (l,b) is the coordinate of the bottom-left vertex, and (r,t) is the coordinate of the top-right vertex. The width and height of each rectangle are between 1 and 20000 respectively. 輸入只有 3 行，每一行上會有 4 個整數，分別表示左下角和右上角座標，保證每個矩形的長寬介於 1 到 20000 之間。",
        "outputFormat": " You should output the area specified above in a single line. 輸出一行一個整數。",
        "sampleInput": [
            "0 2 3 5\n1 0 4 3\n2 1 5 4\n",
            "1 0 3 2\n2 3 4 5\n0 1 5 4\n"
        ],
        "sampleOutput": [
            "20\n",
            "19\n"
        ],
        "hint": "Denote the cardinality of set A\nas |A|\n, the union of sets A\nand B\nas A+B\n, and the intersection of sets A\nand B\nas AB\n, we have |A+B+C|=|A|+|B|+|C|−|AB|−|AC|−|BC|+|ABC|\n.\n",
        "AC": 654,
        "WA": 1194
    },
    {
        "id": 53,
        "title": "Permutation",
        "description": " Write a program to output all permutations of N numbers. The permutations must be outputted in sorted order according to the first number, then the second number, and so on.",
        "inputFormat": " The first line of the input gives the integer N(0<N≤9). The second line contains N numbers separated in a space to be processed. The N numbers are guaranteed to be distinct.",
        "outputFormat": " The output should be consisted of M lines where M is the number of different permutations of the given N numbers. Each line consists of N numbers separated by a space representing a unique permutation. Be aware of the order of those permutations.",
        "sampleInput": [
            "4\n30 10 20 40\n"
        ],
        "sampleOutput": [
            "10 20 30 40\n10 20 40 30\n10 30 20 40\n10 30 40 20\n10 40 20 30\n10 40 30 20\n20 10 30 40\n20 10 40 30\n20 30 10 40\n20 30 40 10\n20 40 10 30\n20 40 30 10\n30 10 20 40\n30 10 40 20\n30 20 10 40\n30 20 40 10\n30 40 10 20\n30 40 20 10\n40 10 20 30\n40 10 30 20\n40 20 10 30\n40 20 30 10\n40 30 10 20\n40 30 20 10\n"
        ],
        "hint": "Suppose we have 4 numbers, 10, 20, 30, and 40. The problem of finding all the permutations of these 4 numbers can be divided into four smaller problems. The first problem is to find all the permutations of 20, 30, and 40, then place a 10 in front of each one of the permutations found. Similarly we can place a 20 in front of all permutations of 10, 30, and 40, a 30 in front of all permutations of 10, 20, and 40, and a 40 in front of all permutations of 10, 20, and 30. These are the permutations we are looking for.\n",
        "AC": 784,
        "WA": 481
    },
    {
        "id": 54,
        "title": "Number of Appearance",
        "description": " Write a program to report the number of times a number N appears in another number M. These appearances may overlap. Limits10≤N≤991000000≤M≤9999999 Input Write a program to report the number of times a number N appears in another number M. The number N is between 10 and 99, and the number M is between 1000000 and 9999999, inclusively. Output The output has only one number, namely the number of times N appears in M.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "90 9090999\n",
            "11 1110111\n"
        ],
        "sampleOutput": [
            "2\n",
            "4\n"
        ],
        "hint": "",
        "AC": 1291,
        "WA": 371
    },
    {
        "id": 55,
        "title": "The Robots",
        "description": " Write a program to predict the fate of two robots. Suppose we have two robots running in an M(horizontal) by N(vertical) unit grid. Both will move at the speed of one square per time step. The first robot carries F1 amount of fuel and the second robot carries F2. If a robot runs out of fuel, it will stop at that square. Moving to a new square requires one unit of fuel. During the first N1 time steps, the first robot R1 will move to the north; then, it will move towards the east during the next E1 time steps. The first robot will repeat this pattern until it runs out of fuel. The second robot R2 will move a little bit differently. During the first E2 time steps, the second robot R2 will move to the east; then, it will move towards the north during the next N2 time steps. Again the second robot will repeat this pattern until it runs out of fuel. If either robot moves \"out of bound,\" it will \"wrap around\" and reappear (by sort of magic) on the other side of the field. For example, if M=7 and N=6 and a robot at (5,5) goes north, it will reappear at (5,0). In addition, if two robots move into the same square, they explode. Now given the starting position of the first robot at (X1,Y1), and the second robot at (X2,Y2), and the amount of fuel they carry (F1 and F2), determine whether the two robots will explode or not. Input There is only one line of inputs that contains M,;N,;X1,;Y1,;E1,;N1,;F1,;X2,;Y2,;E2,;N2,;F2, with the following constraints.0<N,;M<100000≤X1,;X2<M0≤Y1,;Y2<N(X1,Y1) is not (X2,Y2)0<N1,;E1,;N2,;E20≤F1,;F2≤10000 Output There are two cases of output. If two robots explode, output robots explode at time T, where T is the time they explode. Otherwise, output robots will not explode.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "7 6 2 0 9 2 100 3 5 2 7 100\n",
            "7 6 2 0 9 2 6 3 5 2 7 0\n"
        ],
        "sampleOutput": [
            "robots explode at time 5\n",
            "robots will not explode\nPoem\n我知道我們屬於不同的世界. 我們追尋不同的方向. 我們依循不同的週期. 但是, 如果我願意用一輩子的時間等待. 那麼, 在我燈枯油盡之前. 我們是否能有 相逢的一天?\n"
        ],
        "hint": "",
        "AC": 791,
        "WA": 1560
    },
    {
        "id": 58,
        "title": "Lakes",
        "description": " Write a program to recognize lakes. We are given a N by M picture, and each pixel indicates whether that cell is land or water. A lake is defined as a set of water cells that are connected. Two cells are connected if they have the same x coordinate, and their y coordinates differ by exactly 1, or they have the same y coordinate, and their x coordinates differ by exactly 1. The size of a lake is the number of water cells in it. Input There first line of input has N and M(1≤N,M≤400), the dimension of the picture. Each of the next N line has M numbers. A 1 indicates a water cell and a 0 indicates a land cell. Output The out has L lines, where L is the number of lakes in the picture, which is at most N⋅M/2+1. The i-th line has the size of i-th largest lake.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "10 8\n1 1 1 1 1 1 1 1\n1 0 0 0 0 0 0 1\n1 0 0 1 1 0 0 1\n1 0 1 1 1 1 0 1\n1 0 0 0 0 1 0 1\n1 0 1 0 0 1 0 1\n1 0 1 1 1 1 0 1\n1 0 0 1 1 0 0 1\n1 0 0 0 0 0 0 1\n1 1 1 1 1 1 1 1\n"
        ],
        "sampleOutput": [
            "32\n15\nPoem\n我環顧四週，追尋流水的方向， 我雖不能像上帝一樣，在水面行走， 但是我思念的腳步，卻沒有不能到達的地方， 因為這一步，這一生的結束， 就是下一步，下一世的開始。\n"
        ],
        "hint": "",
        "AC": 634,
        "WA": 1089
    },
    {
        "id": 65,
        "title": "Expression Tree",
        "description": " Write a program to compute an expression using a tree. Consider the expression 4 + x * 7. We will use the following recursive definition to express this expression tree. A positive integer or a variable is an expression tree.( operator left-tree right-tree ) is also an expression tree if operator is one of the '+', '-', '*', or '/', and both left-tree and right-tree are expression trees. Following this definition, we can use ( + 4 ( * x 7 ) ) to denote the previous expression. Now given an expression tree and the values of all variables, compute the value of this expression. Input The first line of the input is the expression tree, which is less than 1000 characters. Note that every two adjacent elements of an expression tree are separated by a space. The name of the variables are valid C variable names, with no more than 32 characters. The next n lines (n≤50), where n is the number of variables in the expression tree, indicates the value of the variable, in a form as variable = v, also separated by a space. Output The output is the value of the expression tree.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "( + 4 ( * x 7 ) )\nx = 5\n"
        ],
        "sampleOutput": [
            "39\n"
        ],
        "hint": "C 語言變數命名規則\n採用英文二十六的大小寫字母為主 ('a-z', 'A-Z')，另加上數字 '0-9'、底線符號 '_' 及金錢符號 '$'\n不以數字開頭\n",
        "AC": 329,
        "WA": 646
    },
    {
        "id": 72,
        "title": "Fill the Array",
        "description": " Write a program to fill an array with integers. We will be given an array ptr of n pointers to integers. The first element of ptr points to the first element in an integer array, and the last element of ptr points to the last element. Now we need to write an integer to every element of this integer array according to the following rules. If an integer in the array is pointed by a pointer within the array ptr, then its value should be the index of that pointer within the array. If an integer in the array is not pointed by a pointer within the array ptr, its value should be the sum of the two values of the two nearest elements to its left and to its right in the array that are pointed by pointers within the array ptr. You should implement the following function to assign values according to description above. The parameter ptr is the array of pointers, and n is the number of pointers in ptr. You only need to write the fill_array function.1 void fill_array(int *ptr[], int n); p72.png Test main.c12345678910111213141516#include <stdio.h>#include \"fill_array.h\" int main() {int arr[100] = {};int *ptr[100];int n = 6, m = 0;int A[100] = {0, 5, 6, 9, 3, 12};for (int i = 0; i < n; i++) {ptr[i] = &arr[A[i]];if (A[i] > m)    m = A[i];}fill_array(ptr, n);for (int i = 0; i <= m; i++)printf(\"%d%c\", arr[i], \" \\n\"[i==m]);return 0;} Note2019/9/13 Update: The initial values of the integer array is arbitrary.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 849,
        "WA": 1568
    },
    {
        "id": 73,
        "title": "3n, 3n + 1, and 3n + 2",
        "description": " Write a program to count the number of integers that are 3n, 3n+1, and 3n+2 respectively. 統計有多少數字被 3 除餘 0、餘 1、餘 2。",
        "inputFormat": " The first line has the number of input integers n. Each of the following n lines has an input integer.",
        "outputFormat": " Output the numbers of integer that are 3n, 3n+1, 3n+2.",
        "sampleInput": [
            "5\n1\n2\n3\n4\n5\n",
            "10\n3\n1\n4\n1\n5\n9\n2\n6\n5\n3\n"
        ],
        "sampleOutput": [
            "1 2 2\n",
            "4 3 3\n"
        ],
        "hint": "",
        "AC": 1296,
        "WA": 1206
    },
    {
        "id": 74,
        "title": "Mn, Mn + 1,",
        "description": " Write a program to count the number of integers which can be written as M⋅k,M⋅k+1,... and M⋅k+M−1 respectively. 統計有多少整數被 M 除餘 0、餘 1、...、餘 M−1。",
        "inputFormat": " The first line has the number of input integers N. Each of the following N lines has an input integer. The last line has M.1≤M≤200000",
        "outputFormat": " the number of integers which can be written as M⋅k,M⋅k+1,... and M⋅k+M−1.",
        "sampleInput": [
            "5\n1\n2\n3\n4\n5\n3\n",
            "10\n3\n1\n4\n1\n5\n9\n2\n6\n5\n3\n3\n"
        ],
        "sampleOutput": [
            "1\n2\n2\n",
            "4\n3\n3\n"
        ],
        "hint": "",
        "AC": 1124,
        "WA": 2133
    },
    {
        "id": 75,
        "title": "Count Letters",
        "description": " Write a program to compute the number of different letters in a string. Your program should first read the string using scanf(), then compute the number of different letters in this string. Note that 'a' and 'A' are the same. The output consists of 26 lines, and each line has the number of times that letter appears in the string.",
        "inputFormat": " A single line contains a string S without any space character (except the new line character at the end).|S|≤100",
        "outputFormat": " Output the number of times that each letter appears, each in a line.",
        "sampleInput": [
            "a33bc44d---666AB7C%%D\n"
        ],
        "sampleOutput": [
            "2\n2\n2\n2\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"
        ],
        "hint": "",
        "AC": 959,
        "WA": 445
    },
    {
        "id": 76,
        "title": "Strings",
        "description": " Given some strings, sort them by strcmp and strcpy/qsort then output.",
        "inputFormat": " There are strings in the input, one per line, with no more than 32 characters each. Note that there could be spaces in each line, so you should use fgets or gets to read the input. And you should determine the number of strings using the return value NULL of fgets/gets. The number of strings is no more than 64.",
        "outputFormat": " The sorted strings, one per line.",
        "sampleInput": [
            "There are strings in the input,\none per line, with no more than\n32 characters each. Note that\nthere could be spaces in each\nline, so you should use fgets\nor gets to read the input. And\nyou should determine the number\nof strings using the return\nvalue NULL of fgets/gets.  The\nnumber of strings is no more\nthan 64.\n"
        ],
        "sampleOutput": [
            "32 characters each. Note that\nThere are strings in the input,\nline, so you should use fgets\nnumber of strings is no more\nof strings using the return\none per line, with no more than\nor gets to read the input. And\nthan 64.\nthere could be spaces in each\nvalue NULL of fgets/gets.  The\nyou should determine the number\n"
        ],
        "hint": "",
        "AC": 332,
        "WA": 387
    },
    {
        "id": 77,
        "title": "Get the i-th Element in a List",
        "description": " Now you have a linked list, write a function to get the i-th element in this list. The function has the following prototype: struct node *getNode(struct node *head, unsigned int i); You only need to implement this function. This function will return a pointer that points to the i-th element in the linked list, with i=0 being the last element and the indices are counted in reverse order. If i is too large for the list, you should return NULL. The list won't be empty, and the last node's pointer next will point to NULL. Please include this line #include \"node.h\" when submitting. The content in node.h is like the following: node.h12345678#ifndef _NODE_H#define _NODE_Hstruct node {struct node *next;};#endif",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 457,
        "WA": 1602
    },
    {
        "id": 80,
        "title": "Triangle",
        "description": " Given the three coordinates of three vertices of a triangle, determine whether it is an isosceles triangle, an acute triangle, an obtuse triangle, or a right triangle. Here we assume that all coordinates are integers. Note that if an triangle is an isosceles triangle, you cannot report it as an acute triangle nor a right triangle. To avoid lose of accuracy it is strongly suggested that you compute the three squares of the length of sides, rather than to compute the length. Suppose the square of the longest side is a2, then you can determine the shape of the triangle by comparing it with b2 and c2, which are the squares of the other two sides. 平面上座標上，給定三角形的三個頂點座標，決定是否為等腰、銳角、鈍角或者是直角三角形。你可以假設所有座標皆為整數。特別注意，如果一個三角形為等腰三角形，那麼就不必回報它是否為銳角或鈍角。 為了防止計算誤差，若需要紀錄三角形的三邊長，最好使用其邊長的平方儲存，假設三邊長由長到短分別為 a, b, c，那麼只需要比較 a2, b2, c2 之間的關係即可得到。 p80.jpg",
        "inputFormat": " The first line contains one integer, n, indicate the number of input cases below. The following are n lines, each contains six integers, x1,y1,x2,y2,x3,y3, which are the three coordinates of three vertices of the triangle. Each integer is non-negative and less than 1,000. All the input data will form a triangle correctly.",
        "outputFormat": " For each case, print the type of the triangle, isosceles, acute, obtuse, or right.",
        "sampleInput": [
            "4\n0 0 1 1 1 0\n0 0 1 3 3 0\n0 0 1 1 3 0\n0 0 1 2 1 0\n"
        ],
        "sampleOutput": [
            "isosceles\nacute\nobtuse\nright\n"
        ],
        "hint": "",
        "AC": 1347,
        "WA": 1746
    },
    {
        "id": 85,
        "title": "Sort Dates",
        "description": " Write a program to sort dates. A date consists of year, month, and day. A date is smaller than another date if it comes before the other. For example, (1989,12,31) is smaller than (1990,1,1). Note that there are a large number of dates so using bubble sort will simply be a waste of time. You should use qsort to speed things up.",
        "inputFormat": " Input file contains a integer n(1≤n≤1,000,000), which indicates the number of dates to be sort. And the following n lines each contains three integers, Y, M and D, which represent the year, month and day of the date.",
        "outputFormat": " Output the sorted dates line by line.",
        "sampleInput": [
            "10\n2009 4 9\n2009 2 16\n2010 4 1\n2010 10 23\n2009 9 1\n2009 11 21\n2009 10 12\n2010 3 27\n2009 1 4\n2009 11 12\n"
        ],
        "sampleOutput": [
            "2009 1 4\n2009 2 16\n2009 4 9\n2009 9 1\n2009 10 12\n2009 11 12\n2009 11 21\n2010 3 27\n2010 4 1\n2010 10 23\n"
        ],
        "hint": "",
        "AC": 455,
        "WA": 1542
    },
    {
        "id": 87,
        "title": "Merge Lists",
        "description": " Write a program to merge two linked lists. The node of the list has two members -- a data value of type int, and a pointer next pointing to the next node. We assume that there will be no two nodes in the lists having the same data, and the two lists are sorted such that the data in them are in increasing order. Now you need to merge these two lists by reordering nodes in them so that that they appear as one sorted list. That is, when you are given two list (2, 4, 6, 9) and (1, 3, 10), the final list will be (1, 2, 3, 4, 6, 9, 10). The prototype of this function is as follows:1 struct node *merge(struct node *list1, struct node *list2); The two lists are list1 and list2. The head of the final list will be the return value of merge, and it will always be either list1 or list2. We assume that both list1 and list2 are not NULL, and they are both null terminated. Note that you need to sort the list by reordering only, so you are not allowed to declare array or use malloc(). node.h1234567891011#ifndef _NODE_H#define _NODE_Hstruct node {int value;struct node * next;};struct node * merge(struct node *, struct node *);#endif main.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include <stdio.h>#include <stdlib.h>#include \"node.h\"#define LEN 1000struct node * build(int v[], int n) {struct node * head, * ptr;int i;if (!n)return 0;head = (struct node *) malloc(sizeof(struct node));ptr = head;head -> value = v[0];for (i = 1; i < n; i++) {ptr -> next = (struct node *) malloc(sizeof(struct node));ptr = ptr -> next;ptr -> value = v[i];}ptr -> next = 0;return head;}void print(struct node * ptr) {printf(\"%d\", ptr -> value);if (ptr -> next) {putchar(' ');print(ptr -> next);}}int main() {int n1, n2;int v1[LEN], v2[LEN];int i;struct node * list1, * list2;scanf(\"%d\", &n1);for (i = 0; i < n1; i++)scanf(\"%d\", &v1[i]);scanf(\"%d\", &n2);for (i = 0; i < n2; i++)scanf(\"%d\", &v2[i]);list1 = build(v1, n1);list2 = build(v2, n2);print(merge(list1, list2));putchar('\\n');return 0;}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "There is a very clean recursive solution for this problem. Consider the two heads of these two lists. Which node should appear first in the final answer ?\nYou can download node.h and main.c here, but remember you only need to submit the code of the merge function and the include tags needed (such as node.h).\n",
        "AC": 473,
        "WA": 499
    },
    {
        "id": 88,
        "title": "AB Numbers",
        "description": " Determine the A and B values for two input numbers. You have two numbers, each consisting of 4 different digits from 1 to 9. You should determine two values. The A value is the number of digits that are the same and appear in the same locations. For example, the A value of 1234 and 1253 is two since both 1 and 2 are the same and appear in the same locations. The B value is the number of digits that are the same but appear in different locations. For example, the B value of 1234 and 1253 is 1, since 3 appears in both numbers but appears in different locations.",
        "inputFormat": " Two numbers in a line to determine the A and B values. Both numbers consist of 4 different non-zero digits.",
        "outputFormat": " A single string of n A m B where n is the A value and m is the B value determined for the input.",
        "sampleInput": [
            "1234 1345\n"
        ],
        "sampleOutput": [
            "1A2B\n"
        ],
        "hint": "",
        "AC": 1265,
        "WA": 551
    },
    {
        "id": 89,
        "title": "File Encoding",
        "description": " Write a program to encode a file. You will be given a key from standard in between 0 and 255, and you need to read every byte from the file test, then exclusive or it with the key, then write the result to file test.enc. Please read and write files in binary mode.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "63\n(The filename will always be test)\n"
        ],
        "sampleOutput": [
            "(In file test.enc)\n"
        ],
        "hint": "範例 test 格式下載 here\n範例 test.enc 格式下載 here\n範例標準串流輸入 here\n參考寫法如下：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#include <stdio.h>\n#include <stdlib.h>\n #define MAXN 65536\nint main() {\n    FILE *fin = fopen(\"test\", \"rb\");\n    FILE *fout = fopen(\"test.enc\", \"wb\");\n    int key, size_n;\n    char buf[MAXN];\n     scanf(\"%d\", &key);\n     while ((size_n = fread(buf, 1, MAXN, fin)) != 0) {\n        for (int i = 0; i < size_n; i++)\n            buf[i] ^= key;\n        fwrite(buf, sizeof(char), size_n, fout);\n    }\n    fclose(fout);\n    fclose(fin);\n    return 0;\n}\n",
        "AC": 862,
        "WA": 701
    },
    {
        "id": 93,
        "title": "Heap",
        "description": " Build a heap data structure. A heap should support the following functions: heap.h123456789101112131415#ifndef HEAP_H#define HEAP_H#define MAXHEAP 100struct Heap{int ary[MAXHEAP];int num;};void initialize(struct Heap *heap); int removeMin(struct Heap *heap); void add(struct Heap *heap, int i); int isFull(struct Heap *heap); int isEmpty(struct Heap *heap);#endif The maximum number of elements in a heap is defined as MAXHEAP, which you could define as 100 in heap.h. Now you need to turn in two files, heap.h and heap.c. The heap.h should include the definition of struct Heap, MAXHEAP, and the function declaration of initialize, removeMin, add, isFull, and isEmpty. The file heap.c contains the implementations of these functions. Note that removeMin always removes and return the minimum element in the heap, and the add function simply adds an element (a positive integer) into the heap. For example, one can add 1, 3, 5, and 1, into the heap in any order, and the following four removeMin will return 1, 1, 3, and 5 in this order. Note that this problem is NOT about performance so you do not need to use binary heap or other fancy data structures to do it. A simple array implementation should be enough. You should submit the heap.c and heap.h separately.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 403,
        "WA": 1063
    },
    {
        "id": 94,
        "title": "Tree Traversal",
        "description": " Given a binary tree, traverse it in this HLHR order. An HLHR order is to traverse the root of the tree first, then traverse the left subtree (if exists) in HRHL order, then traverse the root again, then traverse the right subtree (if exists) in HRHL order. Similarly, an HRHL order is to traverse the root of the tree first, then traverse the RIGHT subtree (if exists) in HLHR order, then traverse the root again, then traverse the LEFT subtree (if exists) in HLHR order. Now given a binary tree, traverse it and print the data in this binary tree in HLHR order. Each data will be printed in a line. The tree is given in a format as in homework 11. tree",
        "inputFormat": " The input has only one line that represents a tree in the format mentioned above, and the tree is non-empty. The length of input is no more than4000.",
        "outputFormat": " You should output one integer per line whenever you visit a node. See sample I/O for clarification.",
        "sampleInput": [
            "((10,20),(30,40))\n"
        ],
        "sampleOutput": [
            "100\n30\n20\n20\n30\n10\n10\n100\n70\n40\n40\n70\n30\n30\n"
        ],
        "hint": "",
        "AC": 462,
        "WA": 323
    },
    {
        "id": 96,
        "title": "Cow and House",
        "description": " Write a program to determine how much grass a cow can eat. A cow is attached to a rope of length c, and the other end of the rope is attached to a corner of a rectangular house of width a and depth b. Please determine the area the cow can browse. p96.png Input The input has three double precision number a, b, and c. Output The output has a double precision number (in %f) format. Bounds We assume that π=3.1415926.0<a,b≤1000 c≤a+b",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "10.0 10.0 5.0\n"
        ],
        "sampleOutput": [
            "58.904861\n"
        ],
        "hint": "",
        "AC": 864,
        "WA": 1035
    },
    {
        "id": 97,
        "title": "Bicycle and Parking Lot",
        "description": " National Taiwan University wants to enforce bicycle parking regulations by moving illegally parked bicycles to remote parking lots. There are n parking lots for these illegally parked bicycles. The i-th parking lot is located at (xi,yi) and has a capacity of ci bicycles. The university moves an illegally parked bicycle to the nearest parking lot. The distance between a bicycle and a parking lot is the sum of their absolute value in x and y coordinates. For example, the distance between (1,3) and (−2,2) is 3+1=4. If there are two nearest parking lots, we choose the one with a smaller x coordinate. If the x coordinates are the same, we choose the one with a smaller y coordinate. If all nearest parking lots are full, that is, already have their capacity of bicycles, we move the bicycle to one of the second nearest parking lots, and so on. We assume that the total capacity of all parking lots is sufficient for all illegally parked bicycles. Given the locations and capacity of all parking lots, please determine the parking lots a sequence of illegally parked bicycles will go to. Input The first line of the input is the number of parking lots n. Each of the following n lines has the x, y coordinate, and the capacity of a parking lot. The next line has an integer m, the number of illegally parked bicycles. Each of the next m lines has the x and y coordinates of the bicycle. We move the bicycles according to the order in the input. Output The output has n lines. The i-th line is the number of bicycles in the i-th parking lots after moving all m bicycles to the parking lots. Bounds n is positive and no more than 10. m is positive and no more than 100000. The x and y coordinates are all between -10000 and 10000.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "2\n1 1 1\n100 100 100\n3\n0 0\n2 2\n3 3\n"
        ],
        "sampleOutput": [
            "1\n2\n"
        ],
        "hint": "",
        "AC": 1067,
        "WA": 2881
    },
    {
        "id": 98,
        "title": "Food Ingredients in Common",
        "description": " A Food has many ingredients. For example, a cake is made of egg, flour, sugar, and butter and an omelet is made of egg, bacon, and ham. As a result the common ingredients of cake and omelet is egg. Now write a program to determine the common ingredients of given two foods. Input The first line of the input is n, the number of foods. Each of the next n lines starts with the food, followed by a number i, then number of ingredients, then followed by the names of the i different ingredients. All names of food and ingredients consist of lower case letter only. The next line is m, the number of queries. Each of the following m line has the names of two foods. Output The output has m lines. The i-th line lists the names of common ingredients for the i-th query. You must output the names in dictionary order. If there is no common ingredients for a query, you must output “nothing”. It is guaranteed that no ingredient is called “nothing”. Limits n is positive and no more than 100 i is positive and no more than 10 The length of food and ingredient names are positive and no more than 64.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "3\ncake 4 egg flour sugar butter\nomelet 4 egg bacon ham butter\nbread 1 flour\n2\ncake omelet\nomelet bread\n"
        ],
        "sampleOutput": [
            "butter egg\nnothing\n"
        ],
        "hint": "",
        "AC": 553,
        "WA": 1776
    },
    {
        "id": 99,
        "title": "Bingo",
        "description": " Write a program to play bingo. A bingo board has m rows and m columns. Each entry has a different number from 1 to m×m. The numbers from 1 to m×m will be randomly called. If a player has all the numbers in a row, a column, or a diagonal called he can declare bingo and win the game. Now given the bingo boards of n players, determine who wins the bingo. Input The first line of the input has n and m. Each of the next m lines has the m numbers of the bingo board of the first player. The next line has the name of the second player, and the next m lines have the numbers for the second player, and so on. The next line has m×m numbers that are called in sequence during the bingo game. Output Print the indices of the winners of the game and by which number they won the game. If there are more than one winner, print the player indices one by one according to the order they appear in input. Limits n positive is no more than 10. m is positive and no more than 256. The length of a name is positive and no more than 64. The name consist of only letters.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "2 3\nAlice\n1 2 3\n4 5 6\n7 8 9\nBlob\n1 2 3\n4 5 6\n7 8 9\n1 2 4 8 6 3 9 5 7\n"
        ],
        "sampleOutput": [
            "3 Alice Blob\n"
        ],
        "hint": "",
        "AC": 733,
        "WA": 4678
    },
    {
        "id": 100,
        "title": "Snake Order",
        "description": " Write a program to sort a matrix of integer into snake order as follows. p100.png Your need to write the following function to sort a matrix into snake order.1 void snake(const int *ptr_array[100][100], int m); Note that the first parameter is a two dimensional array of pointers to constant integer, so do not try to change the value pointed by the pointer in the array. Instead you should exchange the pointers in order to sort. Your function should work with the following main program.1234567891011121314151617181920212223242526272829303132#include <stdio.h>#include <assert.h>void snake(const int *ptr_array[100][100], int m);int main(){int array[100][100], check[100][100];const int *ptr_array[100][100];int i, j, m;scanf(\"%d\", &m);for (i = 0; i < m; i++)for (j = 0; j < m; j++) {ptr_array[i][j] = &(array[i][j]);scanf(\"%d\", &(array[i][j]));check[i][j] = array[i][j];}snake(ptr_array, m);for (i = 0; i < m; i++) {for (j = 0; j < m; j++) {assert(check[i][j] == array[i][j]);assert((ptr_array[i][j] >= &array[0][0]) && (ptr_array[i][j] <= &array[99][99]));printf(\"%d \", *(ptr_array[i][j]));}printf(\"\\n\");}return 0;} Input The first line of the input has the m. Each of the next m lines has the numbers in a row of the matrix. Output The output has m lines. Each of the m lines is a row in the sorted matrix in snake order.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "3\n59 33 2\n14 45 16\n51 4 27\n"
        ],
        "sampleOutput": [
            "2 4 14\n33 27 16\n45 51 59\n"
        ],
        "hint": "You can think of the two dimensional array as a single one dimensional array, and perform a bubble sort on this one dimensional array.\nWhat is the difference between const int, const int const, and int const *?\n",
        "AC": 773,
        "WA": 847
    },
    {
        "id": 103,
        "title": "Triangular Matrix Solver",
        "description": " Write a program to solve a system of equations. In particular we are given an n by n upper triangular matrix A and a n by 1 vector y, and we would like to find another n by 1 vector x so that Ax=y. Since A is upper triangular, i.e., all the elements below the diagonal are zero, we can use a simple procedure called backward substitution to get the vector x. Since An,n×xn=yn, so we conclude that xn=yn/An,n. Since we know xn now, we can easily compute xn−1, then xn−2, and so on, until we finally compute x1. Input The first line of the input has the number of rows and columns n. n is between 1 and 16. Each of the following n lines has n double numbers in A. Each of the following n lines has the numbers in y. Note that all elements of matrix and vector are double numbers. Output The output has n lines. Each line is a number in x. You should output the double numbers in %f\\n format.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "3\n1.0 2.0 3.0\n0.0 2.0 1.0\n0.0 0.0 4.0\n2.0\n3.0\n-4.0\n"
        ],
        "sampleOutput": [
            "1.000000\n2.000000\n-1.000000\n"
        ],
        "hint": "",
        "AC": 811,
        "WA": 451
    },
    {
        "id": 104,
        "title": "Material Composition",
        "description": " Write a program to determine whether we can use up all materials in making goods. There are three kinds of materials A, B, and C, and there are also three kinds of good, D, E, and F. To make a D we need DA units of material A, DB units of material B, and DC units of materials C. Similarly for E we need EA, EB and EC units of materials A, B, C, and for F we need FA, FB, and FC units of materials A, B, and C. Now given the units of materials A, B, and C available, could we make goods D, E and F, and use up ALL materials? Note that we do not need to make every kind of goods. Input The first line of the input has DA, DB, and DC. The second line of the input has EA, EB, and EC, and the third line has FA, FB, and FC. Then the next line has n, the number of test cases. Each test case has a, b, and c in a line, as the units of available material A, B and C in this test case. All numbers are integers between 1 and 10. Output The output has n lines. If in a test case we can use up all materials, then output \"yes\\n\". Otherwise output \"no\\n\".",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1 1 2\n2 3 1\n1 2 4\n5\n1 1 1\n1 1 2\n6 8 6\n10 10 10\n4 6 7\n"
        ],
        "sampleOutput": [
            "no\nyes\nyes\nno\nyes\n"
        ],
        "hint": "Could you use recursion to transform this problem in to many smaller and similar problems?\nLimitation\nIn this problem, the use of keyword for, while, goto, are forbidden.\n",
        "AC": 661,
        "WA": 877
    },
    {
        "id": 106,
        "title": "Divisible",
        "description": " Write a program to determine if a number is divisible by 2,3,5, and 11. The rules are as follow. A number is divisible by 2 if the last digit is divisible by 2. A number is divisible by 3 if the sum of the digits is divisible by 3. A number is divisible by 5 if the last digit is 0 or 5. A number is divisible by 11 if the difference between the sum of the even positioned digits and the the sum of the odd positioned digits is divisible by 11. For example the number 190949 is not divisible by 2 because 9 is not divisible by 2. It is not divisible by 3 because 1+9+0+9+4+9=32 is not divisible by 3. It is not divisible by 5 because the last digit is 9. It is divisible by 11 because the sum of even positioned digits is 9+9+9=27, and the the sum of odd positioned digits is 1+0+4=5. The difference between 27 and 5 is 22, which is divisible by 11. Limits The number of digits in a number is no more than 1000. Note that the number of digits could be very large so you cannot store the number in an int. Input The input has several lines. Each line has a positive integer. A -1 indicates the end of input. Output For each input number your program should output four yes or no, which are separated by a space character. These yes and no indicate whether the input number is divisible by 2,3,5, and 11.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "190949\n20\n-1\n"
        ],
        "sampleOutput": [
            "no no no yes\nyes no yes no\n"
        ],
        "hint": "",
        "AC": 861,
        "WA": 1372
    },
    {
        "id": 109,
        "title": "Tree Path Printing",
        "description": " Given a binary tree please print all paths from the root to all leaves. A leaf is a node without any child node, and a path is a sequence of node connecting two nodes. For example, in the figure below there are three leaves -- 1, 8 and 15. The path from the root to the leaf 1 is 9 7 1. p109 You need to implement a function print_all_paths with the following prototype, where you will be given a pointer to the root of the tree.1 void print_all_paths(struct node *root); The declaration of struct node is as follows. You do not need to declare it -- you only need to include a node.h header file to use it. node.h123456789101112#ifndef _NODE_H#define _NODE_Hstruct node {struct node *left;struct node *right;int data;};void print_all_paths(struct node *root);#endif Note that we will separately compile your submission so you should include stdio.h, node.h, and any other header that you will use. Also you are free to write any helper function in your submission. The constraints on the parameters are as follow. The length of a path, i.e., the depth of the tree, is no more than 1000. Input The input tree will be given as a pointer to the root. Output The output are paths from the root to all leaves. You should output a path as a sequence of nodes (indicated by their data) from the root to the leaf. Two adjacent nodes in a path should be separated by a space character. You should print paths in a left-to-right order. main.c12345678910111213141516171819202122232425262728293031323334353637#include <stdio.h>#include <stdlib.h>#include <assert.h>#include \"node.h\"void print_all_paths(struct node *root);struct node *insert_bs_tree(struct node *root, int data){struct node *current;if (root == NULL){current = (struct node *)malloc(sizeof(struct node));assert(current != NULL);current->data = data;current->left = NULL;current->right = NULL;return current;}if (data < root->data)root->left = insert_bs_tree(root->left, data);elseroot->right = insert_bs_tree(root->right, data);return root;}int main(void){int n;struct node *root = NULL;while (scanf(\"%d\", &n) != EOF)root = insert_bs_tree(root, n);print_all_paths(root);}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "9 7 1 8 15\n"
        ],
        "sampleOutput": [
            "9 7 1\n9 7 8\n9 15\n"
        ],
        "hint": "",
        "AC": 479,
        "WA": 566
    },
    {
        "id": 128,
        "title": "City Roads",
        "description": " Write a function to determine the number of intersections in a city. You will be given a city map as a 100 by 100 integer array. When the element in the array is 1, it means there is a section of road in that place. When the element in the array is not 1, then it is not a section of road. Now we define all kinds of intersections. A cell is an intersection if it is 1, and all of its four neighbors are also 1. A cell is a T-junction, if it is 1, and exactly three of its neighbors are also 1. A cell is a turn if it is 1 and exactly two of its neighbors are 1, and these two neighbors do not form a straight line with the cell. A cell is a dead end if it is 1, and exactly one of its neighbors is 1. The prototype of the function is as follows. void intersection(int map[100][100], int result[4]); The map parameter is the city map and the result is where you should place the results - the number of intersection should be placed in result[0], and T-junction should be placed in result[1], etc. Reference Problem 33. Intersections",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 929,
        "WA": 3205
    },
    {
        "id": 129,
        "title": "A Zig Zag Array",
        "description": " Prepare a two dimensional zig-zag array using a free buffer and a pointer array. Note that the numbers of columns in rows of a zig-zag array may be different. The ingredients of a zig-zag array are as follow. An integer row that indicates the number of rows of this two dimensional array. An integer array column[] that specifies the number of columns in that row. An integer buffer, int buffer[10000]; which will be sufficient to hold all elements. An array of integer pointers. int *array[]; This array has the number of row elements. Now you need to implement the following function, so that after calling prepare_array, we can use array[i][j] to access the elements in this prepared two dimensional zig-zag array. void prepare_array(int buffer[], int *array[], int row, int column[]); We will test your function using a code segment like the following.1234567891011121314#include <stdio.h>#include \"prepare_array.h\"int main() {int row = 4;int column[4] = {10, 20, 30, 10};int *array[50];int buffer[10000];prepare_array(buffer, array, row, column);for (int i = 0; i < 4; i++)for (int j = 0; j < column[i]; j++)array[i][j] = i * 100 + j;return 0;}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "If we properly set array[i] to point to a cell in buffer, array[i][j] will be the j-th cell from this location.\n",
        "AC": 702,
        "WA": 720
    },
    {
        "id": 130,
        "title": "Similar Strings",
        "description": " Write a program to determine if two words are similar. Two words are similar if the one of the following two conditions is true. The lengths of the two strings are the same, and one string can be obtained by switching two consecutive characters in the other string. For example, best and bets are similar. The lengths of the two strings differ by 1, and shorter string can be obtained by deleting one character from the longer string. For example, best and bet are similar. Two strings are equal. Now given a set of pairs of strings, determine whether if they are similar. The first line of the input is the number of pairs of string, n. The length of string is no more than 80. Each pair of string has two lines. The output has n lines. If the i-th pair is similar, the output is yes. Otherwise the output is no.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "4\nbest\nbets\nbet\nbest\nbet\nbat\nsample\nsample\n"
        ],
        "sampleOutput": [
            "yes\nyes\nno\nyes\n"
        ],
        "hint": "",
        "AC": 729,
        "WA": 1783
    },
    {
        "id": 132,
        "title": "Color Countries",
        "description": " Write a program to color the countries in a map. Imaging that you have a map, with N countries in it. Your job is to color each country with a color, so that if two countries are adjacent, they will not have the same color. This problem will be trivial if the number of colors, denoted by C, is unlimited, so we will limit the number of colors you can use. Note that there could be multiple sets of solution, and you only need to out one. If here is no solution, you only need to output \"no solution.\\n\".",
        "inputFormat": " The first line of the input has the number of countries, N, and the number of colors you can use, C, and the number of pairs of adjacent countries, P. Each country has an unique index from 0 to N−1. The next P lines describe pairs of countries that are adjacent, and each line has two indices of two adjacent countries. Both N and C are positive. N is no more than 20 and C is no more than 8.",
        "outputFormat": " If there is a solution, output the color you assign to each country according to their indices. You should output exact N lines, with i-th line being the color assignment of the country indexed as i - 1. Assignments are numbered from 1 to C. If there is no solution, output \"no solution.\\n\".",
        "sampleInput": [
            "5 3 7\n0 1\n0 4\n1 2\n1 3\n1 4\n2 3\n3 4\n",
            "4 3 6\n0 1\n0 2\n0 3\n1 2\n1 3\n2 3\n"
        ],
        "sampleOutput": [
            "1\n2\n3\n1\n3\n",
            "no solution.\n"
        ],
        "hint": "",
        "AC": 499,
        "WA": 747
    },
    {
        "id": 133,
        "title": "Word Count with Struct",
        "description": " Write a program to count words using struct. We will write several functions to process strings. The first function will keep tracks of string it has seen. The prototype is as follows.123456 struct string_count {char seen[80];int count;};int compare_and_add(char *string, struct string_count strings[]); Function compare_and_add will compare string with seen stored in strings, and updates the count in strings accordingly. Note that if compare_and_add finds a match, it will return 1 otherwise, it will return 0. The second function will sort the strings according to their frequencies. After we have seen all strings we can print the number of times each string appears in non-decreasing order. Your function must sort strings according to the number of times that string appears. If there is a tie in the number of times two strings appear, the smaller string appears first (according to strcmp). We need the following function to do this.1 void sort(struct string_count strings[]); Finally we need a function to print the strings stored in strings. Each line of the output begins with the number of times a string appears, then a space, then the string itself.1 void print(struct string_count strings[]); A typical scenario may look like this:12345678910111213141516171819/* your uploaded code will be here */ int main() {struct string_count strings[20];int i;for( i=0 ; i<20 ; i++ )strings[i].count = 0;compare_and_add( \"This\", strings );compare_and_add( \"is\", strings );compare_and_add( \"an\", strings );compare_and_add( \"apple,\", strings );compare_and_add( \"and\", strings );compare_and_add( \"this\", strings );compare_and_add( \"is\", strings );compare_and_add( \"a\", strings );compare_and_add( \"book.\", strings );sort( strings );print( strings );return 0;} You must submit something like the following:123456789101112131415#include <stdio.h>#include <string.h> struct string_count {char seen[80];int count;}; int compare_and_add(char *string, struct string_count strings[]) {...} void sort(struct string_count strings[]) {...} void print(struct string_count strings[]) {...} And the program should have the following output:1 This1 a1 an1 and1 apple,1 book.1 this2 is",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 366,
        "WA": 472
    },
    {
        "id": 134,
        "title": "Reconstruct A Binary Tree",
        "description": " Write a program to reconstruct a binary search tree and find the distances of some key pairs. You will be given the keys and their level number in the binary search tree. The level of a tree node is recursively defined as follows. The level of the root is 1 If a node is not the root, then its level is the level of its parent plus 1. We will ask you to compute the distance of each key pair in the following input. Now given the keys, their level numbers, and key pairs to evaluate, you must reconstruct the binary search tree, and output the distance for each key pair. p134 寫一個程式重建一棵二元搜尋樹，並計算二元搜尋樹上給定的兩個節點之間的距離。 Input The first line of the input is the number of tree nodes (N). Each of the next N lines has the key, then the level number of the key. Then there is a number P, with P pairs of keys in the following. You may assume that all keys are different. Also the two keys in every key pair are different. Keys and level numbers are all integers between −231 and 231−1. N≤1000 輸入的第一行為一個整數 n，代表此樹上的節點總數。接下來有 n 行，每行是一個節點的資訊，有兩個整數 d 和 l，分別代表該節點所存放的資料和該節點所在的層級 (註：層級的定義是與根節點的距離加上一，所以根節點本身的層級為 1)。輸入保證資料沒有重複，範圍在 int 之內，且能建回唯一一棵合法的二元搜尋樹。 接有一個整數 p，代表詢問的次數。之後有 p 行，每行有兩個整數 a, b，代表兩個節點的資料。 a, b 保證存在樹上並且相異。 Output The output has P lines. The i-th line is the distance of The output has N lines. The i-th line has the i-th key in pre-order tree traversal. 請輸出 a, b 兩點之間的距離。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "7\n6 1\n3 2\n4 4\n1 3\n2 4\n7 2\n5 3\n3\n3 6\n5 7\n2 4\n"
        ],
        "sampleOutput": [
            "1\n3\n4\n"
        ],
        "hint": "",
        "AC": 518,
        "WA": 529
    },
    {
        "id": 136,
        "title": "Convert a Binary Grade File to HTML",
        "description": " Write a program to read a binary file of student records, and produce a HTML file for display. The definition of the student record is as in the textbook (on page 219). The HTML file should use a table to contain all the fields of a student as a row. You should produce an HTML file that looks like the following. A sample HTML file has been attached to this article.123456789 typedef struct {char name[20];int id;char phone[10];float grade[4];int birth_year;int birth_month;int birth_day;} Student; name1 id1 phone number1 grades1 year1, month1, day1 name2 id2 phone number2 grades2 year2, month2, day2",
        "inputFormat": " The first line of the input is the name of binary file, and the second line of the input is the output HTML file. Each file names have no more than 80 characters. The binary file contains an array of struct student.",
        "outputFormat": " Output your HTML file formatted like the following:<table border=\"1\"><tbody><tr><td>%s</td><td>%d</td><td>%s</td><td>%f, %f, %f, %f</td><td>%d, %d, %d</td></tr></tbody></table>",
        "sampleInput": [
            "students.bin students.html\n"
        ],
        "sampleOutput": [
            "Please referrer to the attached file\n"
        ],
        "hint": "參考 students.bin 下載 here\n參考 students.html 下載 here\n",
        "AC": 570,
        "WA": 1013
    },
    {
        "id": 137,
        "title": "Student Grades",
        "description": " Professor P is very confused by the recent grading system changes. Instead of using 0 to 100 as grades, the university decides to use an A+ to F system. Professor P decides to give the students the 0-100 grades as usual, but he needs a program to convert the 0-100 grades and compute the average. This program will read grades from stdin until EOF, prints each grade, and compute the average. However, professor P expects that this program will behave differently. If a #define HUNDRED is defined, this program will behave like before. The program will print all grades, then compute the average grade using integer arithmetic. On the other hand, if a #define APLUS is defined. This program will behave very differently. First every grade will be converted to a rank from A+ to F. Each rank has a corresponding grade between 0 and 4.3, which we will define as rank grade. You program will then compute the average rank grade. Finally, each rank has another 0-100 grade, which we will define as 100 grade. You will compute the average 100 grade as well. grade rank rank grade 100 grade90-100 A+ 4.3 9585-89 A 4.0 8780-84 A- 3.7 8277-79 B+ 3.3 7873-76 B 3.0 7570-72 B- 2.7 7067-69 C+ 2.3 6863-66 C 2.0 6560-62 C- 1.7 600-59 F 0 50",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "66 33 99\n"
        ],
        "sampleOutput": [
            "66 33 99 66.0\n",
            "C F A+ 2.1 70.0\n編譯參數\n$ gcc a.c -std=c99 -O2 -DHUNDRED -o test1\n$ gcc a.c -std=c99 -O2 -DAPLUS -o test2\n"
        ],
        "hint": "",
        "AC": 304,
        "WA": 374
    },
    {
        "id": 190,
        "title": "Function Evaluation",
        "description": "",
        "inputFormat": " n > 0",
        "outputFormat": "",
        "sampleInput": [
            "We may test your program in the following code:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n#include <stdio.h>\n#include \"evaluate_f.h\"\n int main(){\n  int a[] = { 9, 7 };\n  int b[] = { 3, 2 };\n  int c[] = { 3, 2 };\n  int d[] = { 9, 7 };\n  int *iptr[] = { a, b, c, d };\n  int max, index;\n  max = evaluate_f(iptr, 4, &index);\n  printf(\"%d %d\\n\", max, index);\n}\n"
        ],
        "sampleOutput": [
            "0 1\n"
        ],
        "hint": "",
        "AC": 844,
        "WA": 504
    },
    {
        "id": 195,
        "title": "Tic-Tac-Toe",
        "description": " Now write a program to determine the outcome of a Tic-Tac-Toe game. You will be given the number of moves N, then a series of N moves. Each move is a (x,y) position. First the black player will scan through the move until it finds a legal move, then he plays the move. Next the white player will do the same. Note that any illegal moves are simply disregarded. This process stops when any player wins, or there are no more moves left, and it is a draw. For example, if the moves are (−1,100), (0,0), (0,0), (20,30), (1,1) then the first move of black is (0,0), and the first move of white is (1,1). Your program must determine who wins or it is a draw. The illegal moves are not counted in the number of moves, so the moves made by blacks are always 1, 3, 5, 7, 9, and the white is always 2, 4, 6, 8. 寫程式決定一場井字遊戲的獲勝者。井字遊戲為 3×3 的格子上，雙方輪流下一子，不能下在已經下過的位置，直到其中一方連成一線 (水平、垂直和對角線)。這一題我們假設盤面位置 (x,y) 必須滿足 0≤x,y≤2。若位置不在盤面中或存在其他棋子，則此操作視為不合法。 給定一序列 N 次操作，每一次將棋子放置 (x,y)，黑手和白色輪流下一步，每一子只能下在合法位置，若發現操作中有不合法位置，該手會拋棄這個位置，並等待到下一個合法位置。如果所有操作結束時，發生盤面未填滿且不存在其中一方獲勝，則視為平手 (draw)。",
        "inputFormat": " The first line contains number 0≤N≤1000. There are N lines followed, each of them contains two integers x and y, indicating the current player make a move on (x,y).",
        "outputFormat": " Print a line contains Black wins. or White wins. or There is a draw..",
        "sampleInput": [
            "3\n1 1\n0 0\n0 2\n"
        ],
        "sampleOutput": [
            "There is a draw.\n"
        ],
        "hint": "",
        "AC": 934,
        "WA": 2721
    },
    {
        "id": 202,
        "title": "Mixed Fractions",
        "description": " Write a program to calculate addition, subtraction, multiplication, and division for two mixed fractions. You will be given two mixed fractions -- a b c and e f g. For example, if a=1, b=3, and c=4, then you have 1.75. You can also represent negative number by a negative a, so if a=−1, b=3, and c=4, then the result is -1.75. For simplicity we assume that a and e are always non-zero, b and f are always non-negative, and c and g are always positive. Also, b and c have to be simplified. For example, you cannot have a=1, b=6, and c=8. Also when b or f is 0, c and g must be 1. We will be given an extra number d as the operator. If d is 0, 1, 2, 3, then the operation is addition, subtraction, multiplication, and division, respectively. Now given a,b,c,d,e,f,g, compute the final result as a mixed fraction h i j. Limits The ranges of numbers are as follow. a and e are non-zero and between -100 and 100 inclusively. b, and f are non-negative and no more than 100. c and g are positive and no more than 100. d is always between 0 and 3 inclusively. Input a,b,c,d,e,f,g Output The output follows the same rules as the input. You should output h, i, and j in three lines.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1\n3\n4\n0\n-2\n3\n4\n",
            "2\n0\n1\n2\n-1\n1\n3\n"
        ],
        "sampleOutput": [
            "-1\n0\n1\n",
            "-2\n2\n3\n"
        ],
        "hint": "",
        "AC": 1184,
        "WA": 3565
    },
    {
        "id": 203,
        "title": "Bouncing Balls",
        "description": " Write a program to simulate two bouncing balls in a box. Let's assume that there is a box of width X and height Y, and two balls moving within the box. The initial positions of these two balls are different and given as (x1,y1) and (x2,y2) respectively, and 1<x1,x2<X, 1<y1,y2<Y. The moving direction of these balls are given as (dx1,dy1) and (dx2,dy2). The balls move 1 unit at a second and they always move in 45 degree angle, therefore all dx and dy are either 1 or −1. For example, suppose (x1,y1) is (3,4) and (dx1,dy1) is (−1,1) then after one second the first ball will move to (2,5). The ball will bounce when it hits the wall of the box. Since the ball always moves in 45 degree angle, it is easy to compute its path. For example, suppose (x1,y1) is (2,4) and (dx1,dy1) is (−1,1) then the position of the first ball is (2,4),(1,5),(2,6),... etc. If the ball hits a corner, it bounces back the way it came in. The balls may hit each other and bounce back. We determine if two balls hit into each other by checking whether their positions are the same after they move into their new locations. For example, suppose (x1,y1) is (3,4) and (dx1,dy1) is (−1,1), and (x2,y2) is (3,6) and (dx1,dy1) is (−1,−1), The first ball will go to (3,4),(2,5),(1,4), ... and the second ball will go to (3,6),(2,5),(1,6), ..., etc. Note that by our rules two balls exchanging positions do not collide. I know this is against physics but I do not want to make this problem complicated, so bear with me. Limits5<X,Y<300 Input The input are X,Y,x1,y1,x2,y2,dx1,dy1,dx2,dy2, and the number of seconds you need to simulate. Output The output is the final position of these two balls, in x1, y1, x2, y2 order.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "20\n20\n3\n4\n3\n6\n-1\n1\n-1\n-1\n2\n"
        ],
        "sampleOutput": [
            "1\n4\n1\n6\n"
        ],
        "hint": "",
        "AC": 760,
        "WA": 1469
    },
    {
        "id": 204,
        "title": "House of Mirrors",
        "description": " This exercise 6.10 in the textbook. We have a room with a lot of mirrors. The rectangular room is of size W by D. You can think of the room consists of WD square cells, each is of unit length. Within each cell we may place a mirror. The mirror is two sided so that both sides reflect light. Now there are 2(W+D) windows around the room, each is centered at one of boundary cells, Like in the following figure. If we stand at window 0 and look into the room, we will see the person standing at window 8. Now write a program that, given the position of these windows, calculates the windows number we would be able to see if we stand at a particular window. p243.png Input The first line of the input has two numbers, W and D, representing the width and the depth of the room. Both D and W are positive integers and no more than 100. Each of the next D lines has W numbers, with 1 representing a mirror, and 0 for no mirror. The numbers are from top to bottom, left to right. Output The output has 2(W+D) lines, and each line has one number. The number in the i-th line indicates the window number that can be seen from the i-th window.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "5 4\n0 1 0 1 0\n0 0 1 0 0\n1 0 0 1 1\n0 1 1 0 0\n"
        ],
        "sampleOutput": [
            "8\n7\n5\n9\n6\n2\n4\n1\n0\n3\n17\n15\n14\n16\n12\n11\n13\n10\n"
        ],
        "hint": "",
        "AC": 786,
        "WA": 537
    },
    {
        "id": 206,
        "title": "Card Shuffling",
        "description": " Write a program to simulate shuffling a deck of cards. We will use an array of pointers to represent a deck of card. A card is an integer from 1 to 10000, and the i-th element of this array represent the i-th card in a deck of cards. That is, if the i-th card in the deck is 6, then the i-th pointer in the pointer will point to an integer whose value is 6. If a pointer has NULL then it is the end of deck, and there are no more cards after it, so it is like an \"end of deck\". We also assume that there will be no more than 9999 cards in a deck. Now we want to shuffle a deck of cards. First we cut the deck into two halves. The first half has the first ceil(n/2) cards and the second half has the remaining cards. For example, if there are 9 cards then the first half has 5 cards and the second half has 4 cards. Then we shuffle these two halves into one by placing the first card from the first half as the first card, the first card from the second half as the second card, the second card from the first half as the third card, etc. That is, we interleave these two halves back into a deck of cards. The prototype of this shuffling function is as follows.1 void shuffle(int *deck[]); We also need to be able to print a deck of cards. For this we need the following print_deck function, which will print the cards according to their order in the deck in a single line, with a space between two cards. Note that you will know there are no more cards by the \"end of deck\".1 void print(int *deck[]); A sample main program is as follows. Please finish the program by providing the implementation of shuffle and print.123456789101112131415161718#include <stdio.h>#include \"card.h\"int main(){int card[10000];int *deck[10000];int index = 0;while (scanf(\"%d\", &(card[index])) != EOF) {deck[index] = &(card[index]);index++;}deck[index] = NULL;shuffle(deck);print(deck);return 0;}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1 2 3 4 5\n"
        ],
        "sampleOutput": [
            "1 4 2 5 3\n"
        ],
        "hint": "第二點測資是空檔\n",
        "AC": 958,
        "WA": 2327
    },
    {
        "id": 208,
        "title": "Print a Bitmap",
        "description": " 寫一個程式列印一個點矩陣。我們假設這個點矩陣深度只有一個位元。例如以下即為一3乘12的點矩陣。101010111010010110110001111111100111 我們將用 unsigned int 儲存點矩陣。由於一個 3 乘 12 點矩陣只需要 36 個位元，所以我們可以用兩個 32 位元的 unsigned int 代表。第一個整數數組是 2879762942，而第二個整數是 1879048192。也就是說點矩陣的點數不一定是 32 的倍數。由於點矩陣只需要36個位元，所以第二個整數後面 32×2-36=28 個位元事實上無關緊要所以我們補 0。同時題目保證用最多 1024 個 unsigned int 儲存。 Input 輸入有 3 行。第一行試點矩陣寬度與高度。第二行是當點矩陣為 1 或 0 時要輸出的字元。第三行為代表點矩陣內容的 unsigned int。題目保證給定剛好數目的 unsigned int。 Output 儲存的點矩陣",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "12 3\n* -\n2879762942 1879048192\n"
        ],
        "sampleOutput": [
            "*-*-*-***-*-\n-*-**-**---*\n*******--***\n"
        ],
        "hint": "",
        "AC": 792,
        "WA": 702
    },
    {
        "id": 210,
        "title": "SQL Database",
        "description": " 編寫一個程式來模擬一個資料庫服務器。程式首先會先讀取數據到資料庫，然後一次執行一個查詢命令。 Input 輸入第一部分為資料。第一行為資料筆數 n，n 不超過 50。以下 n 行一行一筆資料。資料內容由以下欄位組成。 lastname，以字串儲存，長度不超過 80 字元。 firstname，以字串儲存，長度不超過 80 字元。 ID，以字串儲存，長度不超過 80 字元。 salary，以整數儲存。 age，以整數儲存。 輸入第二部分是 SQL 查詢命令。命令格式如下：field 可以是 lastname、firstname、ID、salary 或 age。他們可以以任何順序出現並重複。欄位出現的數目至少為一，至多為八。condition 符合的資料才會被輸出。 select field1 field2 ... fieldn where condition 一個 condition 包括 field operator constant。field 為任意欄位。如果比較欄位是字串，operator 可能是 ==、!=。如果比較欄位是數字，operator 可能是 ==、> 或 <。另外 condition 的 constant 長度不超過 80 字元。 Output 輸出為查詢結果。對於每一筆查詢，如果結果有很多筆資料，輸出順序請依照資料的輸入順序。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "4\nLiu Pangfeng A123456789 80000 40\nWu Janet B123456789 79999 30\nLiu Kevin C123456789 0 10\nLiu Eric C123456789 0 7\n2\nselect lastname firstname ID where salary > 1000\nselect firstname lastname salary lastname where lastname == Liu\n"
        ],
        "sampleOutput": [
            "Liu Pangfeng A123456789\nWu Janet B123456789\nPangfeng Liu 80000 Liu\nKevin Liu 0 Liu\nEric Liu 0 Liu\n"
        ],
        "hint": "",
        "AC": 544,
        "WA": 1828
    },
    {
        "id": 215,
        "title": "Chicken, Rabbit and Crab",
        "description": " There are chicken, rabbit, and crab in a cage. Now given the total number of animals s, the total number of legs f, and the total number of tails of these animals t, please compute the numbers of the chicken, rabbit, and crab, respectively. We assume that a chicken has two legs and one tail, a rabbit has four legs and one tail, and a crab has EIGHT legs and NO tail. If there is no solution, your program should output 0. 寫一個程式來解決一下問題。 有雞、兔子和螃蟹在同一個籠子裡。 現給定這些動物的總數(s)、動物腳的總數(f)及動物尾巴的總數(t)，(0<=s, f, t<=2^31-1) 請計算兔子、雞、螃蟹的數量。 如果給定的數字不可能有解，程式應該輸出 0。 Limit0≤s,f,t≤231−1",
        "inputFormat": " Input will consist of one problem instance. Each instance will consist of one line. The first line will be three non-negative integers s,f,t.",
        "outputFormat": " If there is a solution, your program should output the numbers of chickens, rabbits, and crabs. Otherwise, your program should output 0.",
        "sampleInput": [
            "9 48 5\n",
            "9 48 20\n"
        ],
        "sampleOutput": [
            "2\n3\n4\n",
            "0\n"
        ],
        "hint": "",
        "AC": 1352,
        "WA": 2572
    },
    {
        "id": 218,
        "title": "Sum of Selections",
        "description": " 寫一個程式計算從 n 個不同物品中取不超過 m 個物品的方法總數。可以先寫一個計算 C(n,k) 的函式，之後計算 C(n,k), k 由 0 到 m 的和即可。 F(n,m)= m∑ i=0( n i) Input 輸入只有一行 n 及 m。 Output 輸出是 n 個不同物品中取不超過 m 個物品的方法總數。 Limits0<n<150≤m≤n",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "5 2\n"
        ],
        "sampleOutput": [
            "16\n"
        ],
        "hint": "",
        "AC": 885,
        "WA": 855
    },
    {
        "id": 220,
        "title": "Sentence Count",
        "description": " 寫一個程式計算輸入文章中的句子數。為求簡單起見我們假設一個句子的結束必定為一個句點。但是為了避免像 \"Mr.\" \"i.e.\" 這樣的問題，我們規定符合下面四種狀況之一才算是一個句子 : 句點後面必須有兩個連續空白 ' ' 句點後面就是換行 '\\n' 句點後面就是 EOF '\\0' 句點到 EOF 之前只有空白或換行",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "The Declaration of Independence was a\nstatement adopted by the Continental Congress\non July 4, 1776, which announced that the\nthirteen American colonies then at war with\nGreat Britain regarded themselves as independent\nstates, and no longer a part of the British\nEmpire.  Written primarily by Mr. Thomas Jefferson\nthe Declaration was a formal explanation of why\nCongress had voted on July 2 to declare\nindependence from Great Britain, more than a\nyear after the outbreak of the American\nRevolutionary War.  The birthday of the United\nStates of America-Independence Day-is celebrated\non July 4, i.e., the day the wording of the\nDeclaration war approved by Congress.\n"
        ],
        "sampleOutput": [
            "3\n"
        ],
        "hint": "",
        "AC": 748,
        "WA": 2236
    },
    {
        "id": 221,
        "title": "Typesetting",
        "description": " 編寫一個排版程式。程式必須將輸入的字逐一讀入，再逐一輸出。一個字的定義是「連續非空白的字元」，例如 7、empire. 都算是字。也就是說我們可以用 scanf(\"%s\", string) 讀入一個字。 Input 輸入的第一行是每行可輸出的字元數 m，之後就是要排版的文章，每個英文字的最大長度為 256 個字元，輸入請讀取到 EOF 結束。 Output 輸出請將所有的字依序印出，兩個字之間要以至少一個空格隔開。我們的目標是要利用最少且盡量平均分配的空格使得每一行輸出恰好 m 個字元(包含空白，不包含換行)。也就是我們要盡量把字放在同一行，而當我們必須要開新的一行時，若原本的那行字串+空白的長度不足 m，我們要在字之間補上更多的空白。如果空格無法平均分配，則多的空格必須加在前面的字後面。行尾請勿有多的空白，也請勿少空白。最後一行輸出後必須換行。 Limits32≤m≤256，每個字串的字元數保證不會超過 m 個 。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "40\nThe Declaration of Independence\nwas a statement adopted by the\nContinental Congress on July 4,\n1776, which announced that the\nthirteen\nAmerican colonies then at war with\nGreat Britain regarded themselves as\nindependent\nstates, and no longer a part of the British\nEmpire.\nWritten primarily by Thomas Jefferson,\nthe Declaration was a formal explanation of why Congress had\nvoted on July 2 to declare\nindependence from Great Britain, more than\na year\nafter the outbreak of the American Revolutionary War.\nThe birthday of the United States\nof America-Independence Day-is celebrated on\nJuly 4, the day\nthe wording of the Declaration was approved\nby Congress.\n"
        ],
        "sampleOutput": [
            "The  Declaration  of  Independence was a\nstatement  adopted  by  the  Continental\nCongress   on   July   4,   1776,  which\nannounced  that  the  thirteen  American\ncolonies  then at war with Great Britain\nregarded   themselves   as   independent\nstates,  and  no  longer  a  part of the\nBritish  Empire.  Written  primarily  by\nThomas  Jefferson, the Declaration was a\nformal  explanation  of why Congress had\nvoted  on July 2 to declare independence\nfrom  Great  Britain,  more  than a year\nafter   the  outbreak  of  the  American\nRevolutionary  War.  The birthday of the\nUnited  States  of  America-Independence\nDay-is celebrated on July 4, the day the\nwording  of the Declaration was approved\nby                             Congress.\n"
        ],
        "hint": "",
        "AC": 389,
        "WA": 1970
    },
    {
        "id": 222,
        "title": "Bookshelf",
        "description": " 寫一個程式模擬書架。假設你有 255 本書和一個可容納 8 本書的書架。255 本書每本有一個由 1 到255 的號碼，且一開始書都在書櫃裡。8 本書的書架在桌上，且一開始是空的。當我們想看一本書的時候，我們會先在書架上找，如果找到，我們就取出來看，看完就塞回書架的最右邊。如果書架上找不到，我們就從書櫃裡找出來看，看完後一樣塞回書架的最右邊。但此時書架上可能已經有 8 本書了，此時我們就將書架中最左邊的書放回書櫃，將書架上的書向左挪，空出最右邊放我們剛看完的書。請模擬一段時間之後書架的情形。 由於一本書的號碼最大到 255，我們可以用 8 個位元來表示。同時一個 long long int 有8個位元組，剛好可以用來模擬 8 本書的書架。 Input 輸入為一介於 1 到 255 的整數序列，代表我們看書的順序。程式必須處理所有的輸入直到 EOF。 Output 輸出為 8 個整數，代表左到右最後書架中的書的編號，如果書架該位置沒有書則輸出 0。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1 2 3 4 5 6 7 8 6 10 23 7 4\n"
        ],
        "sampleOutput": [
            "3 5 8 6 10 23 7 4\nNotice\n這題有病 by Morris\n當然，你可以偷偷使用優化輸入的技巧。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n#include <stdio.h>\nint hasEOF = 0;\nint readchar() {\n    static int N = 1<<20;\n    static char buf[1<<20];\n    static char *p = buf, *end = buf;\n    if(p == end) {\n        if((end = buf + fread(buf, 1, N, stdin)) == buf) {\n            hasEOF = 1;\n            return EOF;   \n        }\n        p = buf;\n    }\n    return *p++;\n}\nint ReadInt(int *x) {\n    char c, neg;\n    while((c = readchar()) < '-')    {if(c == EOF) return 0;}\n    neg = (c == '-') ? -1 : 1;\n    *x = (neg == 1) ? c-'0' : 0;\n    while((c = readchar()) >= '0')\n        *x = (*x << 3) + (*x << 1) + c-'0';\n    *x *= neg;\n    return 1;\n}\nint main() {\n    int x;\n    while (ReadInt(&x)) {\n        // add your code\n    }   \n    // output your answer\n    return 0;\n}\n"
        ],
        "hint": "",
        "AC": 618,
        "WA": 1949
    },
    {
        "id": 223,
        "title": "Tiles",
        "description": " 寫一個程式使用 2×2 的 L 形磚鋪滿一個 L 形廣場。2×2 有四種類型，分別用 1、2、3、4 的數字為代表。見下圖： p9.png p223-sample 現在你需要把這些使用 2×2 的 L 形磚鋪滿一個 L 形廣場。L 形磚不能重疊，且恰好覆蓋整個 L 形廣場。L 形廣場的長度與寬度均為 l，L 形廣場右上角缺損部分的長度與寬度均為 m。l 和 m 均為 2 的次方，且 1≤m<l≤64。請輸出一個使用 L 形磚鋪滿一個 L 形廣場的方法。 Input 輸入有兩個數字 l 和 m。 Output 輸出是瓷磚的位置。每行有三個數字，第一個數字是 L 形磚的類型，第二個和第三個數字是 L 形磚中心要放的位置 (即每一片磁磚的凹向內的直角頂點位置)。方便起見，我們假設 L 形廣場的左下角頂點位於 (0,0)，每一片磁磚皆放在第一象限。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "8 4\n"
        ],
        "sampleOutput": [
            "",
            "1 4 4\n4 3 5\n1 3 3\n2 5 3\n4 2 6\n3 3 7\n4 1 7\n1 1 5\n1 2 2\n4 1 3\n1 1 1\n2 3 1\n2 6 2\n3 7 3\n2 7 1\n1 5 1\n"
        ],
        "hint": "",
        "AC": 370,
        "WA": 647
    },
    {
        "id": 224,
        "title": "Supervisors and Subordinates",
        "description": " 寫一個程式決定兩個員工的關係。程式的主程式和初始化的函數已寫好，因此你要做的是實作三個輔助函數和判斷關係的函數。三個輔助函數分別是：以名字找員工、以員工編號找員工、找一名員工最頂層的的老闆。 員工的資料我們定義如下：每一個員工有一個唯一的員工號碼 id，姓 last_name，名 first_name，及直屬上司的員工號碼 boss_id。每個員工只有一個直屬上司，而且可以是自己。在這份作業中，我們以一個結構來定義員工資料。 employee.h12345678910111213141516171819#ifndef _EMPLOYEE_H#define _EMPLOYEE_Hstruct employee{int id;char first_name[32];char last_name[32];int boss_id;}; typedef struct employee Employee;void init_storage(Employee **storage, int n); void free_storage(Employee **storage); Employee* find_employee_by_id( Employee *set, int n, int id ); Employee* find_employee_by_name( Employee *set, int n, const char *first_name, const char *last_name ); Employee* find_root_boss( Employee *set, int n, Employee *employee ); int check_relationship(Employee *set, int n, Employee *A, Employee *B);#endif 初始化和結束的兩個函數實作請見以下。 employee.c123456789101112131415161718#include <stdio.h>#include <stdlib.h>#include <string.h>#include \"employee.h\"void init_storage(Employee **storage, int n){// allocate memory space to store employee data// no need to understand this function now.(*storage) = (Employee *)malloc(sizeof(Employee) * n);}void free_storage(Employee **storage){free(*storage);*storage = 0;} 主程式流程則請見以下。 main.c123456789101112131415161718192021222324252627282930313233343536373839404142#include <stdio.h>#include \"employee.h\"int main(){int n, m;int i;Employee *set = NULL;scanf(\"%d\", &n);init_storage(&set, n);for ( i = 0 ; i < n ; i++ )scanf(\"%d %s %s %d\", &(set[i].id), set[i].first_name, set[i].last_name, &(set[i].boss_id));char first_name_A[32], first_name_B[32];char last_name_A[32], last_name_B[32];Employee *A, *B;int type;scanf(\"%d\", &m);for ( i = 0 ; i < m ; i++ ){scanf(\"%s %s\", first_name_A, last_name_A);A = find_employee_by_name(set, n, first_name_A, last_name_A);scanf(\"%s %s\", first_name_B, last_name_B);B = find_employee_by_name(set, n, first_name_B, last_name_B);type = check_relationship(set, n, A, B);switch(type){case 1:printf(\"subordinate\\n\"); break;case 2:printf(\"supervisor\\n\"); break;case 3:printf(\"colleague\\n\"); break;default:printf(\"unrelated\\n\"); break;}}free_storage(&set);return 0;} 兩個員工 A 和 B 的關係定義如下： 如果 A 可藉由一連串的「直屬上司」關係連結到 B，則稱 A 是 B 的部屬 (subordinate) 。 如果 B 可藉由一連串的「直屬上司」關係連結到 A，則稱 A 是 B 的長官 (supervisor) 。 如果 A 與 B 並非部屬/長官關係，但存在另一個 C，且 A 與 B 皆為 C 的部屬，則 A 和 B 互為同事(colleague) 關係。 如果以上皆非，則 A 與 B 為無關係 (unrelated)。 Input 輸入的第一行為 n，代表員工數目。以下 n 行都為員工號碼、姓、名及直屬上司的員工號碼。接下來會有一個數字 m 代表查詢次數，以下 m 行為想查詢的兩個員工姓名。員工的姓名保證存在於輸入中，且代表兩個不同的員工。 Output 輸出有 m 行，每一行為想查詢的兩個員工姓名之間的關係。關於輸入輸出的處理和分工，以及初始化函數的使用，請參閱主程式。 Limits0<n≤32,0<m",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "6\n100 John Smith 200\n200 Adam Johnson 300\n300 Jane Washington 300\n400 Mary Miller 300\n500 Eric Page 500\n600 James Clark 500\n4\nJohn Smith Adam Johnson\nJane Washington Adam Johnson\nAdam Johnson Mary Miller\nMary Miller James Clark\n"
        ],
        "sampleOutput": [
            "subordinate\nsupervisor\ncolleague\nunrelated\n"
        ],
        "hint": "",
        "AC": 518,
        "WA": 574
    },
    {
        "id": 225,
        "title": "Friends",
        "description": " 編寫一個程式決定朋友關係，首先我們需要定義什麼是人，我們假設最多處理 10000 人，最多有 10000 對朋友。每一個人都有一個介於 0 和 9999 的整數編號，以及不超過 31 個字元的名字。我們以如下的結構表示。1234 struct person {unsigned int id;char name[32];}; 根據一般定義朋友是彼此的，所以我們用下面的結構來描述兩位朋友。1234 struct friends {unsigned id1;unsigned id2;}; 假設你有一個包含所有朋友訊息的二進制檔案 friends 檔案，friends 依序包含以下的資料。 系統中的人數 P，佔四個位元組 P 個 struct person 的內容 系統中的朋友對數 F，佔四個位元組 F 個 struct friends 的內容 請參考範例 friends。檔案 friends 有 4 個人的資訊 - John, Mary, Tom, Jack. 而且 Mary 和 John 是朋友，Tom 和 Mary 是朋友。 Input 輸入每行為一個命令，包含兩個朋友，只含有 end 的一行表示輸入的結束。另外你必須讀入一個包含 struct friends 結構的二進制檔案 friends。 Output 如果輸入兩個名字為朋友，也就是說，存在一個 struct friends 的內容與兩個名字相符，則輸出 yes，否則輸出 no。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "John Mary\nTom Mary\nJack Tom\nend\n"
        ],
        "sampleOutput": [
            "yes\nyes\nno\n"
        ],
        "hint": "參考 friends 格式下載 here\n",
        "AC": 585,
        "WA": 1072
    },
    {
        "id": 230,
        "title": "The Knapsack",
        "description": " 假設有 n 個物件和一個背包。第 i 個物件的重量為 wi，價值為 vi，而背包有總重量限制 W。如何選擇物件放入背包中，使得放入背包的物件總重量不超過背包總重量量限制 W，且使得放入背包的物件總價值為最大？ Input 輸入第一行為物件個數 n 及背包重量限制 W。接下來會有 n 行，每行有兩個數字，分別是第i個物件的重量 wi 和價值 vi。 Limits0<n≤200<W≤100000<wi,vi≤1000",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "5 6\n3 1\n1 3\n2 3\n3 5\n3 5\n"
        ],
        "sampleOutput": [
            "11\n"
        ],
        "hint": "可以使用遞迴的方法來求答案。如果我們將第一個物件放入背包，結果是不是得到一個跟原來問題很相近的問題? 如果我們不將第一個物件放入背包，結果是不是也得到一個跟原來問題很像的問題？\n",
        "AC": 894,
        "WA": 797
    },
    {
        "id": 232,
        "title": "What day is Today?",
        "description": " Write a program to determine the day for a given day. We will first have the year and the day of January first. For example, January first of 2012 is a Sunday. Then we will have the month and day of today. For example, today is November thirteenth. Please determine the day of today, which is a Tuesday. Input The first line has the year and the day of January first. In our example, that will be 2012 0. Note that we use 0 for Sunday, 1 for Monday, etc. The second line is the number of test cases n. n is at least 1 and at most 10. Each of the following n lines has the month and day. In our example, it will be 11 13. If the month is incorrect, you should output -1. If the month is correct but the day is incorrect, you should output -2. Output The is n output lines, and each line has an integer, which is the day of the test case. Here we use 0 for Sunday, 1 for Monday, etc.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "2012 0\n5\n11 13\n11 14\n11 15\n13 1\n1 200\n"
        ],
        "sampleOutput": [
            "2\n3\n4\n-1\n-2\n"
        ],
        "hint": "",
        "AC": 1075,
        "WA": 2791
    },
    {
        "id": 234,
        "title": "Factorization",
        "description": " Write a program to factorize a polynomial. We will be given a polynomial f(x)=x3+ax2+bx+c, where all a,b,c are all integers between -100000 and 100000. Now we want to factorize f(x) as (x+d)(x+e)(x+f), where d, e, and f are all integers, and d≤e≤f. Input A line containing a, b, and c. Output A line containing d, e, and f.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "12 47 60\n"
        ],
        "sampleOutput": [
            "3 4 5\n"
        ],
        "hint": "",
        "AC": 966,
        "WA": 5055
    },
    {
        "id": 235,
        "title": "Pachinko",
        "description": " Write a program to simulate a Pachinko. For this problem, we will use a very simple pachinko. There are N rows of pins in this pachinko. The i-th pin of a row is between the i-th and (i−1)-th pin in the previous row, as shown in the figure below. When a ball drops on a pin, it will go either left or right. This probability varies from pin to pin. After hitting N pins, the ball will fall into one of the N+1 buckets. After knowing the probability of going left or right for every pin, compute the probability that a ball falls into each N+1 bucket. The number of rows of pins N is less than or equal to 15. p235.jpg Input The first line of the input has the number of rows N. The next N(N+1)/2 line has two integers a, b, that indicate the ratio of the probability that the ball will go left or right. The probability ratio is given from top to bottom, from left to right. a,b≥0, and it is guaranteed that one of a,b>0. Output Please output N+1 lines -- each has a fractional number. The i-line has the probability of the ball falling into the i-th bucket. Each line has a ratio of q/p to indicate the probability. You need to simplify the q/p ratio; you should output 1/2 instead of 2/4.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "2\n1 2\n2 3\n3 1\n"
        ],
        "sampleOutput": [
            "2/15\n7/10\n1/6\n"
        ],
        "hint": "In order to prevent arithmetic overflow, you should reduce the denominator and numerator of each fractional number you use.\n",
        "AC": 529,
        "WA": 1844
    },
    {
        "id": 236,
        "title": "Least Common Multiplier",
        "description": " Given a set of positive integers, compute their least common multiplier. For example, if you are given 2, 3, 4, and 5, then the least common multiplier is 60, because 60 is the smallest multiplier of 2, 3, 4, and 5. 給一個正整數集合，請計算集合的最小公倍數。例如給定 2, 3, 4, 5，它們的最小公倍數為 60，60 是可以被 2, 3, 4, 5 整除的最小的正整數。 Input The input has a line of positive integers. You must process all integers in this line. 輸入只有一行，這一行上有數個正整數。 Output The output has the least common multiplier of input integers. Note that it is guaranteed that all the computation can be done in the range of int. 輸出一行一個整數，保證答案一定在 32-bit 內。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "2 3 4 5\n"
        ],
        "sampleOutput": [
            "60\n"
        ],
        "hint": "It is easy to see that the product of the least common multiplier and the greatest common divisor of two positive integers is the product of these two positive integers. For example, lcm(6,15)×gcd(6,15)=30×3=6×15\n.\n",
        "AC": 1008,
        "WA": 1004
    },
    {
        "id": 238,
        "title": "Subset Sum",
        "description": " Given a set of different positive integers, write a program to compute the numbers of ways to select a subset so that the sum of the integers of in the subsets is exactly a given integer k. For example, given a set {1, 2, 3} and k = 3, then there are only two subsets whose sum is k, namely {1, 2} and {3}. If k is 5 then the only subset is {2, 3}. If k is 7 then there are no such subsets. Input The first line of the input is n, the number of numbers. n is at least 1 and at most 15. The next line has n positive integers in the set. Each of the following line has an integer k. You must process all k until EOF. Output Each output corresponds to a number k.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "3\n1 2 3\n3\n5\n7\n"
        ],
        "sampleOutput": [
            "2\n1\n0\n"
        ],
        "hint": "Consider the first number in the set. If we choose this number, then what kind of problem do we have? If we do not choose this number then what kind of problem do we have?\n",
        "AC": 1075,
        "WA": 822
    },
    {
        "id": 239,
        "title": "Daily Expense",
        "description": " Write a program to keep track of your expenses. You will be given a sequence of expenses. Each expense consists of year, month, date, category, and amount. Year, month, date, and amount are positive integers, and the category is a string. After reading these expenses, you need to make a summary report about your expense for every day. The report will be sorted in ascending date order, and in each day the expenses are sorted in category based on alphabetic order. However, the expenses for the same day and the same category should be combined. Each input line is an expense. Each expense has year, month, date, category, and amount. All year, month, date are positive integer. The category is a string of length at most 32. There will be at least 1 and at most 10000 expenses. You should process all expenses until EOF. The output is a summary report according to the description above. 批改娘曰 Execution time > 1 second 即斬 !!",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "2012 1 1 food 23\n2012 1 1 food 3\n2012 10 10 rent 3000\n2010 10 1 food 34\n2012 1 2 food 5\n2012 10 10 food 10\n"
        ],
        "sampleOutput": [
            "2010 10 1 food 34\n2012 1 1 food 26\n2012 1 2 food 5\n2012 10 10 food 10\n2012 10 10 rent 3000\n"
        ],
        "hint": "",
        "AC": 356,
        "WA": 275
    },
    {
        "id": 240,
        "title": "Square, Diamond, and Rectangle",
        "description": " Given four different points on the plane, determine the shape of this polygon. There are several cases. If the length of the four sides are the same, and the four angles are right, then it is a square. For example, the polygon by (−1,0),(0,1),(1,0),(0,−1) is a square. If the length of the four sides are the same, but the four angles are not right angle, then it is a diamond. For example, polygon by (−2,0),(0,1),(2,0),(0,−1) is a diamond. If the length of the four sides are not the same, but the four angles are right angle, then it is a rectangle. For example, polygon by (0,0),(0,1),(2,1),(2,0) is a rectangle. 給定平面上四個點，它們彼此不共點，請判斷這個多邊形的形狀，有以下三種可能： 如果四邊長度相同以及角度為直角，它們即是正方形，如多邊形 (−1,0),(0,1),(1,0),(0,−1) 就是個正方形。 如果四邊長度相同但角度不是直角，它們即是菱形，如多邊形 (−2,0),(0,1),(2,0),(0,−1) 就是個菱形。 如果四邊長度不同且四個角均是直角，它們即是長方形，如 (0,0),(0,1),(2,1),(2,0) 就是個長方形。 不屬於上述三者，請回報 other Input The first line has the number of test data n. n is at least 1 and at most 100000. Each of he next n line has a test data. Each test data line has 8 integers for the four points. The first two are the x and y coordinates of the first point, etc. Since the difference between two x coordinates, or two y coordinates is bounded by 10000, you may assume that the computation can be safely done with int. It is also guaranteed that there will be no three points in a straight line, and the quadrilateral is convex and unique. The four points may be given in any order. Output Output the shape for each input line. You should output square, diamond, rectangle according to the definition above. If the polygon does not fit into any definition, output other.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "4\n-1 0 0 -1 0 1 1 0\n-2 0 2 0 0 -1 0 1\n0 1 2 1 0 0 2 0\n0 1 0 0 2 1 2 -10\n"
        ],
        "sampleOutput": [
            "square\ndiamond\nrectangle\nother\n"
        ],
        "hint": "You can easily check whether an angle is a right angle by Pythagorean theorem - a2+b2=c2.\n你可以使用向量外積的正負號，讓輸入的點按照順或逆時針的方式排列。\n",
        "AC": 1001,
        "WA": 3605
    },
    {
        "id": 241,
        "title": "Origin in Quadrilateral",
        "description": " Given a convex quadrilateral Q, please determine if the origin (0,0) is with Q. For example, if Q has four corners (2,1), (−1,2), (−2,−1), and (−1,−3) then the answer is yes. If Q is (12,1), (9,2), (8,−1), and (9,−3) then the answer is no. 給一個凸四邊形 Q 的四個頂點座標，請問原點 (0,0) 是否在四邊形內部，如果原點在四邊形內部，輸出 1，反之，請輸出 0。 p241-example 1: origin in Q p241-example 2: origin not in Q Input The input consists of eight integers, a,b,c,d,e,f,g, and h, representing the four corners (a,b),(c,d),(e,f), and (g,h) in counterclockwise order. It is guaranteed that the four sides of the Q will not be parallel to either x or y axis, and will not contain the origin. The absolute value of all numbers is no more than 100. 輸入包含八個整數 a,b,c,d,e,f,g,h，按照逆時針順序給定座標 (a,b),(c,d),(e,f),(g,h)。請注意：四邊形的邊不一定平行於座標兩軸，座標的絕對值小於等於 100。 Output The output is either 1 or 0, representing that the origin is within or not within Q.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "2 1 -1 2 -2 -1 -1 -3\n",
            "12 1 9 2 8 -1 9 -3\n",
            "→\na\n=(2,1),\n→\nb\n=(−1,2),\n→\nc\n=(−2,−1),\n→\nd\n=(−1,−3)\n.\nOrigin in Q\nif and only if it must satisfy that\n→\na\n×\n→\nb\n=2⋅2−1⋅(−1)=5>0\n,\n→\nb\n×\n→\nc\n=(−1)⋅(−1)−2⋅(−1)=3>0\n,\n→\nc\n×\n→\nd\n=(−2)⋅(−3)−(−1)⋅(−1)=3>0\n, and\n→\nd\n×\n→\na\n=(−1)⋅(1)−(−3)⋅(2)=5>0\n"
        ],
        "sampleOutput": [
            "1\n",
            "0\n"
        ],
        "hint": "In computational geometry of the plane, the cross product is used to determine the sign of the acute angle defined by three points p1=(x1,y1)\n, p2=(x2,y2)\nand p3=(x3,y3)\n. It corresponds to the direction of the cross product of the two coplanar vectors defined by the pairs of points p1,p2\nand p1,p3\n, i.e., by the sign of the expression P=(x2−x1)(y3−y1)−(y2−y1)(x3−x1)\n... Cross product Computational geometry - wiki\nRay casting algorithm O(n)\n- Wiki / Convex Polygon O(logn)\nArea summation method (Note: Be careful about arithmetic overflow)\n",
        "AC": 1350,
        "WA": 1417
    },
    {
        "id": 242,
        "title": "Three Circles",
        "description": " You are given three circles, C1,C2, and C3. The center of C1 is at (x1,y1), and its radius is r1. The centers and radius of C2 and C3 are defined similarly. A point (x,y) is within a circle if its distance is less than or equal to the radius of the circle. For example, Both (1,0) and (0,0) are within the circle that centered at (0,0) and has radius 1. Now given the centers and radius of the three circles, please find the number of points (x,y) where both x, and y are integers, that are within odd number of circles. Note that the circles can overlap arbitrarily, however, the radius is no more than 10. As a result you must be careful about how to test points, so that your program will run fast, and without doing unnecessary testing.",
        "inputFormat": " The first line of the input is the number of input cases. Each input case has three lines and each line has the x, y, coordinates of a circle, followed by the radius. The radius is no more than 10.",
        "outputFormat": " For each test case output the number of points (x,y) where both x, and y are integers, that are within odd number of circles.",
        "sampleInput": [
            "2\n0 0 1\n0 0 2\n2 0 1\n0 0 1\n1000000 0 1\n0 1000000 1\n"
        ],
        "sampleOutput": [
            "11\n15\n"
        ],
        "hint": "",
        "AC": 847,
        "WA": 1527
    },
    {
        "id": 244,
        "title": "Lottery",
        "description": " Please write a program to calculate the lottery prize. Each lottery number is an 8-digit integer. You will have three special prize numbers and three first-prize numbers. We determine the prize according to the following rules. A number matching a special prize number receives 2000000 dollars. A number matching a first prize number receives 200000 dollars. A number whose last 7 digits match the last 7 digits of a first prize number receives 40000 dollars. A number whose last 6 digits match the last 6 digits of a first prize number receives 10000 dollars. A number whose last 5 digits match the last 5 digits of a first prize number receives 4000 dollars. A number whose last 4 digits match the last 4 digits of a first prize number receives 1000 dollars. A number whose last 3 digits match the last 3 digits of a first prize number receives 200 dollars. Input The first three lines of the input are the special prize numbers. The second three lines are the first prize number. The rest of the input is the lottery numbers, one per line. All the numbers are positive integers between 10000000 and 99999999. You must process all numbers until the end of the file. Output The output is the sum of the dollars from all lottery numbers.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "55138690\n14764045\n41175733\n68787608\n77978391\n11071074\n12378391\n68787608\n"
        ],
        "sampleOutput": [
            "204000\n"
        ],
        "hint": "",
        "AC": 1053,
        "WA": 1324
    },
    {
        "id": 248,
        "title": "Mine Field",
        "description": " Write a program to find the mines. There is a nine by nine minefield, in which each cell could have a mine. Now you have the number of mines of all (up to eight) neighboring cells and the cell itself, and you need to determine the locations of all mines. For example, if you know the numbers of mines as follows.1 1 2 1 1 1 1 1 02 2 3 2 2 3 2 2 02 2 3 2 2 3 3 3 12 3 2 2 1 2 3 3 22 3 1 2 2 3 5 4 34 6 3 3 3 4 5 4 35 7 4 3 3 4 4 4 36 9 6 4 2 2 1 3 34 6 4 3 1 1 0 2 2 Then the locations of mines will be like the following.0 0 0 0 0 0 0 0 00 1 0 1 0 0 1 0 00 1 0 0 1 0 1 0 00 0 0 0 0 0 0 1 01 0 1 0 0 0 0 1 01 0 0 0 1 1 1 1 01 1 1 0 0 1 0 0 11 1 1 0 0 0 0 0 11 1 1 0 1 0 0 0 1 Note that we do not guarantee that there are solutions. If there is no solution, output \"no solution\\n\". If there are multiple solutions, output the one that has the minimum value, i.e., if you consider the solution as an 81-bit unsigned integer, where bits are from top to bottom, from left to right.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1 1 2 1 1 1 1 1 0\n2 2 3 2 2 3 2 2 0\n2 2 3 2 2 3 3 3 1\n2 3 2 2 1 2 3 3 2\n2 3 1 2 2 3 5 4 3\n4 6 3 3 3 4 5 4 3\n5 7 4 3 3 4 4 4 3\n6 9 6 4 2 2 1 3 3\n4 6 4 3 1 1 0 2 2\n"
        ],
        "sampleOutput": [
            "0 0 0 0 0 0 0 0 0\n0 1 0 1 0 0 1 0 0\n0 1 0 0 1 0 1 0 0\n0 0 0 0 0 0 0 1 0\n1 0 1 0 0 0 0 1 0\n1 0 0 0 1 1 1 1 0\n1 1 1 0 0 1 0 0 1\n1 1 1 0 0 0 0 0 1\n1 1 1 0 1 0 0 0 1\n"
        ],
        "hint": "",
        "AC": 389,
        "WA": 648
    },
    {
        "id": 249,
        "title": "Company",
        "description": " Write a program to determine the relation between two employees in a company. Every employee is described by a record like the following. 撰寫管理公司員工之間的關係的程式，每一個員工的記錄格式如下所附： struct employee {int id;char first_name[32];char last_name[32];int boss_id;}; The id is a unique identification number of an employee. The first_name and last_name are the names of an employee. The boss_id is the identification number of the boss of the employee. Two employees have one of the following relation. If an employee A can follow the \"boss\" relation to an employee to another employee B, then A is a subordinate of B, and B is a supervisor of A. If A and B have a common supervisor C, then A and B are colleague If none of the above is true, then A and B are unrelated. 其中每一個員工都擁有自己獨一無二的 id 編號，而 first_name 和 last_name 則是員工的名字，最後一個 boss_id 則是指該名員工的上司編號。兩名員工之間的關係分成以下三種： 如果員工 A 可以藉由 boss 關係找到 B，則表示 B 為 A 的上司，意即 A 是 B 的下屬。 如果 A 和 B 有共同的上司，則 A 和 B 是同事。 如果上述觀係都不成立，則 A 和 B 之間沒有關係。 此外，這種關係是遞移的。例如，A 是 B 的上司，且 B 是 C 的上司，則 A 是 C 的上司。同理，B 是 A 的下屬，且 C 是 B 的下屬，則 C 是 A 的下屬。 Input The first line of the input is the number of employees n, which is no more than 32. The next n lines are the information of the employees. The next line is the number of queries m. Each of the next m has the names of two employees. Since m could be quite large so you must process a query once you read it. These two names will be different. 第一行會有一個整數 n 表示有多少名員工，保證不多於 32 名員工，接下來會有 n 行，每一行上會有一個員工資訊，分別為員工的 id, first_name, last_name。接著會有一個整數 m，表示接下來會有 m 個詢問關係，接下來會有 m，每一行上會有兩個人名，保證詢問的兩個人名都不相同。 Output The output has m lines. Each line indicates the relation between the two employees. 對於每個詢問輸出一行關係。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "6\n100 John Smith 200\n200 Adam Joshson 300\n300 Jane Washington 300\n400 Mary Miller 300\n500 Eric Page 500\n600 James Clark 500\n4\nJohn Smith Jane Washington\nJane Washington Adam Joshson\nAdam Joshson Mary Miller\nMary Miller James Clark\n"
        ],
        "sampleOutput": [
            "subordinate\nsupervisor\ncolleague\nunrelated\n"
        ],
        "hint": "",
        "AC": 600,
        "WA": 904
    },
    {
        "id": 251,
        "title": "Company, Again",
        "description": " Redo homework 9 with a tree data structure. Instead of employee id now we have a pointer pointing to the boss of an employee, as suggested by the following definition. Note that two different employees may have the same boss, but one employee will only have one boss. The total number of employees is no more than 32. If an employee has no boss, then his/her boss pointer will point to himself/herself. employee.h1234567891011#ifndef EMPLOYEE_H#define EMPLOYEE_Htypedef struct employee {char first_name[32];char last_name[32];struct employee *boss;} Employee;int relation(Employee *employee1, Employee *employee2);#endif Now implement the following function that returns the relation of employee1 to employee2. employee.c12345#include \"employee.h\"int relation(Employee *employee1, Employee *employee2) {//} main.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include <stdio.h>#include <string.h>#include <assert.h>#include \"employee.h\"typedef struct me {int id;char first_name[32];char last_name[32];int boss_id;} employee;void readName(employee *e) {scanf(\"%s %s\", e->first_name, e->last_name);}int nameToIndex(employee *e, employee A[], int n) {for (int i = 0; i < n; i++) {if (!strcmp(A[i].first_name, e->first_name) &&!strcmp(A[i].last_name, e->last_name))return i;}return -1;} int main() {int n, m;employee A[32];Employee B[32];const char out[4][32] = {\"subordinate\", \"supervisor\", \"colleague\", \"unrelated\"};while (scanf(\"%d\", &n) == 1) {for (int i = 0; i < n; i++) {scanf(\"%d\", &A[i].id);readName(&A[i]);scanf(\"%d\", &A[i].boss_id);}for (int i = 0; i < n; i++) {strcpy(B[i].first_name, A[i].first_name);strcpy(B[i].last_name, A[i].last_name);B[i].boss = NULL;}for (int i = 0; i < n; i++) {for (int j = 0; j < n; j++) {if (A[i].boss_id == A[j].id)B[i].boss = &B[j];}}scanf(\"%d\", &m);employee x, y;for (int i = 0; i < m; i++) {readName(&x);readName(&y);int ix = nameToIndex(&x, A, n), iy = nameToIndex(&y, A, n);assert(ix != -1);assert(iy != -1);printf(\"%d\\n\", relation(&B[ix], &B[iy]));}}return 0;} Again we need the following definition. If employee1 can follow the \"boss\" relation to employee2, then return 1. If employee2 can follow the \"boss\" relation to employee1, then return 2. If employee1 and employee2 have a common supervisor, then return 3. If none of the above is true, then return 4.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "6\n100 John Smith 200\n200 Adam Joshson 300\n300 Jane Washington 300\n400 Mary Miller 300\n500 Eric Page 500\n600 James Clark 500\n4\nJohn Smith Jane Washington\nJane Washington Adam Joshson\nAdam Joshson Mary Miller\nMary Miller James Clark\n"
        ],
        "sampleOutput": [
            "1\n2\n3\n4\n"
        ],
        "hint": "",
        "AC": 424,
        "WA": 449
    },
    {
        "id": 253,
        "title": "Time Object",
        "description": " Write an object for time. A time consists of a hour, minute, and second. You need to supply the following functions. 撰寫記錄時間的物件，時間記錄包含小時、分鐘以及秒，你還必須完成下述的函數：1234567891011121314#ifndef MWTIME#define MWTIMEtypedef struct Time {int hour;int minute;int second;} Time;void initTime(Time *time); void setTime(Time *time, int hour, int minute, int second); void addTime(Time *time, int hour, int minute, int second); void printTime(Time *time);#endif The initTime is to set the time to 00:00:00. The setTime is to set the time in 24 hour format. The addTime is to add a amount of time. This may cause overflow. For example, if you add two hours to 11pm then your will get 1am. The printTime is to output the time. If the symbol H24 is defined, then you need to print the time in 24 hour format. For example, if the time is 15 after 3pm, then you should output 15:15:00. If the H24 symbol is not defined, you should print 03pm:15:00. 函數有下列幾種： 函數 initTime 將物件初始化時間為 00:00:00。 函數 setTime 以 24 小時制設定時間單位。 函數 addTime 增加時間量，這可能會造成溢出，例如晚間 11pm 增加 2 個小時會到跨日的 1am。 函數 printTime 會要求輸出兩種格式，若有定義 H24 則程式要輸出 24 小時制格式，例如 15:15:00。反之，若沒有定義 24 小時制，則輸出 12 小時制格式，如 03pm:15:00。 特別小心 參考 wiki 12-hour clock00:15:30 在 12 小時制下，應顯示 12am:15:3012:15:30 在 12 小時制下，應顯示 12pm:15:30 編譯參數$ gcc -std=c99 -O2 -c main.c$ gcc -std=c99 -O2 -c time.c -o h12.o$ gcc -std=c99 -O2 -c time.c -o h24.o -DH24 -DinitTime=initTime24 -DsetTime=setTime24 -DaddTime=addTime24 -DprintTime=printTime24$ gcc -std=c99 -O2 main.o h12.o h24.o$ ./a.out",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 283,
        "WA": 896
    },
    {
        "id": 256,
        "title": "One Count Sorting",
        "description": " Write a program to sort numbers according to the number of 1 in their binary representation. For example, 3 is greater than 64 because 3 has two 1's and 64 has only 1. If two numbers has the same number of 1's then the one with larger decimal value is greater. For example, both 6 and 3 has two 1's, and because 6 is larger than 3 in decimal, 6 is larger. Input A set of positive integers less than 263, one per line. You must process them until EOF. The number of integers is no more than 1000. Output The increasing sequence of the input integers, one per line.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "3\n6\n64\n"
        ],
        "sampleOutput": [
            "64\n3\n6\n"
        ],
        "hint": "",
        "AC": 467,
        "WA": 689
    },
    {
        "id": 260,
        "title": "String Fusion",
        "description": " Write a program to do string \"fusion\". The fusion is similar to string concatenation but it will combine the suffix of the first string and the prefix of the second string if they are the same. For example if you fuse \"abcd\" with \"cdef\" then you will get \"abcdef\". Also the fusion will try to fuse as many characters as possible. For example, if you fuse \"abccc\" with \"cccde\" then you will get \"abcccde\", not \"abccccde\", nor \"abcccccde\". Input The input consists of a series of (at least two) nonempty strings consisting of lower case letters, and you need to fuse the next one to the result of previous fusion. You must process all string until EOF. Each string and all the intermediate results have no more than 127 characters. Output The final fusion result.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "a\nb\nc\nbcde\nbcde\ncdefghi\nghi\nghi\nghijk\nabcdefghijklmn\nzzz\nzzzz\nabc\n"
        ],
        "sampleOutput": [
            "abcdefghijklmnzzzzabc\n"
        ],
        "hint": "",
        "AC": 750,
        "WA": 824
    },
    {
        "id": 261,
        "title": "Puzzle Equation",
        "description": " Write a program to solve a puzzle. The puzzle has three strings of upper case letters and digits. Now you need to replace the upper case letters with digits from 1 to 9, so that the product of the first two numbers is the third number. For example, you are given (“ATHF”, “FHTA”, “5HHTAAF”). Now if you replace A with 1, T with 2, H with 3, and F with 4, then you will get (1234, 4321, 5332114), and the product of 1234 and 4321 is indeed 5332114. Note that to make the problem simple, it is not necessary to make the digits for all letters different. For example if you are given (“CD”, “AB”, “242”) then a feasible solution is (22, 11, 242). Also note that we ask for any solution, so (11, 22, 242) is also a solution. Input Three nonempty strings consisting of uppercase letters and digits. In order to avoid overflow while multiplying, the sum of lengths of the first two strings will not exceed 9. Output An equation that shows the product of the first two string after replacing is indeed the third. If there are multiple solutions, output the any one of them. It is guaranteed that all the test inputs are solvable.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "ATHF\nFHTA\n5HHTAAF\n",
            "CD\nAB\n242\n"
        ],
        "sampleOutput": [
            "1234 x 4321 = 5332114\n",
            "22 x 11 = 242\n"
        ],
        "hint": "The first thing you need to do is to find and collect all the upper case letters in the three strings. After that the second thing you need to do is to try all the 1 to 9 combinations on them, and verify each of them. The problem is designed so that you do not need to do any cut. That is, you can always verify your guesses when all the upper case letters are replced by digits, then convert the strings to integers, then verify the equation. Since the problem asks for any answer, you can stop at the first answer you find.\nNotice\n若前導為零，請保持輸出，如 001 x 002 = 002，請保持長度相同 by Morris.\n",
        "AC": 337,
        "WA": 585
    },
    {
        "id": 262,
        "title": "Maximum Number of Consecutive 1's",
        "description": " Write a program to compute the maximum number of consecutive 1's in their binary representation. For example 7 has three consecutive 1's since its binary representation is 00000111. 25 has two because its binary representation is 00011001. Input A set of positive integers no more than 2147483647, one per line. You must process them until EOF. Output The maximum number of consecutive 1's in the input, one per line.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1\n126\n25\n7\n65535\n21\n2147483647\n"
        ],
        "sampleOutput": [
            "1\n6\n2\n3\n16\n1\n31\n"
        ],
        "hint": "",
        "AC": 885,
        "WA": 439
    },
    {
        "id": 264,
        "title": "Byte Frequency Count",
        "description": " Write a program to read data from a file. Your program will open a file with binary read mode. (The file name is given in standard input.) The first four bytes of the file is a positive integer n, which is the number of data afterward. Then there are n two byte signed integers ranging from -32768 to 32767 in binary format. Now you need to determine which number from -32768 to 32767 appears most. If there is a tie, report the largest one. For example, if both 1 and 10 appear 100 times, which is the maximum number of times, then you should report 10. 寫程式以二進制讀入一份檔案，檔案的前 4 個位元組為一個 32-bit 整數 n，表示接下來需要統計 16-bit 有號整數分別出現多少次。請輸出出現最多次的那個數，如果出現次數相同時，以最大的那一個為準。 Input There is a string with maximum length 200, specifying the file name. This string can be read by scanf(\"%s\",...). 請根據標準輸入串流中 (也就是鍵盤輸入) 的第一行字串，作為開檔的檔案名稱，你可以假設不會有特殊的空白表達式，只接使用 scanf(\"%s\",...) 即可。 Output You should output two lines. First line is the number that appears most, and the second line is the frequency of this number. 輸出兩行，第一行為哪個數字出現最多次，第二行為出現最多次的次數。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "0.dat\n"
        ],
        "sampleOutput": [
            "10\n100\n"
        ],
        "hint": "參考 0.data 下載 here\n",
        "AC": 685,
        "WA": 1932
    },
    {
        "id": 265,
        "title": "Minimum Containing Box",
        "description": " Write a program to find the area of the minimum rectangle (with edges parallel to the axes) to contain a set of points. For example, if you are given the following points (1,1), (2,3), (7,6), (−2,7), (−4,20), (0,0), (−3,−3), then the smallest rectangle to contain all the points is the one that has two corners at (−4,−3) and (7,20). You need to print its area, which is 253. Input You must process all input until EOF. There will be no more than 100 points, and all computation is in int. All coordinates are between -10000 and 10000, and there will be at least one point. Output The final area.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1 1\n2 3\n7 6\n-2 7\n-4 20\n0 0\n-3 -3\n"
        ],
        "sampleOutput": [
            "253\n"
        ],
        "hint": "",
        "AC": 810,
        "WA": 326
    },
    {
        "id": 266,
        "title": "Edit Eistance",
        "description": " Write a program to compute the minimum distance among all pairs of a set of strings. The distance between two strings is defined recursively as follows. If one string is empty, then the distance is the length of the other string. For example, the distance between \"\" and \"apple\" is 5. If the first character of the two strings are the same, then their distance is recursively defined as the distance between the two strings after removing the first character. For example, the distance between \"apple\" and \"applepie\" is the distance between \"pple\" and \"pplepie\". If the first character of the two strings are not the same, then their distance is recursively defined as 1 plus the minimum of the following two distances. The distance between the first string and the second string after removing the first character. The distance between the first string after removing the first character and the second string. For example, the distance between \"orange\" and \"apple\" is 1 plus, the minimum of the distance between \"orange\" and \"pple\", and the distance between \"range\" and \"apple\". Input You must process all input until EOF. There will be at least 2 and no more than 100 strings, containing only letters. The lengths of all strings are between 1 and 10. 輸入直到檔案結束，至少 2 個、至多 100 個字串，每個字串長度最多 10 個英文字母，輸入的第 i 行，其字串 ID 為 i。 Output The minimum distance and the IDs of the strings in the minimum distance pair. If there are two pairs with same distance, the pair with smaller 1000∗ID1+ID2 would be considered as smaller. The ID of the first string is 1, and the ID of the second string is 2, and so on. 輸出包含三個整數 edit_distance(stringID1,stringID2),ID1,ID2，若有多組最小距離解，請輸出 ID 字典順序最小的那一對。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "lemon\napple\norange\napplepie\nbigapple\nbanana\nlemonjuice\napples\ncoconut\nstrawberry\nlemons\n"
        ],
        "sampleOutput": [
            "1 1 11\n"
        ],
        "hint": "",
        "AC": 638,
        "WA": 1240
    },
    {
        "id": 267,
        "title": "Traveling Distance",
        "description": " Write a program to compute the total distance to travel through a set of cities. The distance is defined as the sum of the square of the difference between the x coordinates, and the square of the difference between the y coordinates. For example, the distance between (3,2) and (1,3) is 5. Now we first have to determine the order we want to travel. We will start from the origin (0,0), and sort the cities according to their distance to the origin. If there are two cities that have the same distance to the origin, the we will go to the one with the smaller x coordinate first. If x coordinate is still the same, we will go to the one with smaller y coordinate first. For example, if you are given the cities at (1,−1),(1,1),(−1,1),(3,4),(4,3),(2,2), then the order to visit will be (−1,1),(1,−1),(1,1),(2,2),(3,4), and (4,3). Note that (1,−1) and (−1,1) have the same distance but we will go to (−1,1) first. Now we start moving from the origin to the cities. The first trip is from the origin to (−1,1), with distance 2. Then we go from (−1,1) to (1,−1), with distance 8. After traversing all the cities, the total distance will be 23. Input You must process all input until EOF. There will be no more than 100000 cities. It is strongly suggested that you should use qsort so that the cities can be sorted fast enough. All the distance computation can be done in int. Output The final distance.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1 -1\n1 1\n-1 1\n3 4\n4 3\n2 2\n"
        ],
        "sampleOutput": [
            "23\n"
        ],
        "hint": "",
        "AC": 383,
        "WA": 177
    },
    {
        "id": 269,
        "title": "Memory Allocation",
        "description": " Write a program to simulate memory allocation. Recall that we can use malloc to allocate memory. An allocated memory has a starting address and a length, and these allocated memory will not overlap. We want to simulate, after a series of allocations, where the free memory are. Consider the following program:12345678910111213141516#include\"memory.h\"int main() {Memory myMemory;initMemory(&myMemory, 100);printMemory(&myMemory);allocateMemory(&myMemory, 50, 10);printMemory(&myMemory);allocateMemory(&myMemory, 70, 10);printMemory(&myMemory);allocateMemory(&myMemory, 0, 10);printMemory(&myMemory);allocateMemory(&myMemory, 30, 10);printMemory(&myMemory);return 0;} This program uses a memory object. There are three functions for the memory object. initMemory(Memory *memory, int n) will initialize a memory of size n. 1≤n≤1000000000 allocateMemory(Memory *memory, int start, int length) allocates a memory block with a starting address and a length. 0≤start<start+length≤n printMemory(Memory *memory) prints the available free blocks for the current memory. The previous program should produce the following output. Initially the entire memory is free so the only free block starts from 0 and is of length 100. After the first allocation starting at 50 and of length 10, there will be two free blocks now -- one starts at 0 with length 50, and the other starts at 60 with length 40. The memory allocation continues so your memory object should record what memory blocks are still free, so that the prtintMemory can print them correctly.========== start 0, length 100========== start 0, length 50 start 60, length 40========== start 0, length 50 start 60, length 10 start 80, length 20========== start 10, length 40 start 60, length 10 start 80, length 20========== start 10, length 20 start 40, length 10 start 60, length 10 start 80, length 20 I strongly suggest using a linked list to record the free memory blocks. Whenever we have a memory allocations, we can traverse the list, find the necessary block to update. Note that you may need to insert a new free memory block because one might allocate in the middle of a block. You also need to remove a free block since it may be allocated completely. You need to implement the following functions:123 void initMemory(Memory *memory, int length); void printMemory(Memory *memory); void allocateMemory(Memory *memory, int start, int length); The bonus problem is to extend the previous memory object so that it supports free function. This function will release a memory block. void freeMemory(Memory *memory, int start, int length);0≤start<start+length≤n The main program may look like this now: main.c123456789101112131415161718192021222324#include \"memory.h\"int main() {Memory myMemory;initMemory(&myMemory, 100);printMemory(&myMemory);allocateMemory(&myMemory, 50, 10);printMemory(&myMemory);allocateMemory(&myMemory, 70, 10);printMemory(&myMemory);allocateMemory(&myMemory, 0, 10);printMemory(&myMemory);allocateMemory(&myMemory, 30, 10);printMemory(&myMemory);freeMemory(&myMemory, 50, 5);printMemory(&myMemory);freeMemory(&myMemory, 70, 10);printMemory(&myMemory);freeMemory(&myMemory, 30, 10);printMemory(&myMemory);freeMemory(&myMemory, 0, 10);printMemory(&myMemory);return 0;} Now the output should be like this.========== start 0, length 100========== start 0, length 50 start 60, length 40========== start 0, length 50 start 60, length 10 start 80, length 20========== start 10, length 40 start 60, length 10 start 80, length 20========== start 10, length 20 start 40, length 10 start 60, length 10 start 80, length 20========== start 10, length 20 start 40, length 15 start 60, length 10 start 80, length 20========== start 10, length 20 start 40, length 15 start 60, length 40========== start 10, length 45 start 60, length 40========== start 0, length 55 start 60, length 40 You need to implement the additional function:1 void freeMemory(Memory *memory, int start, int length); Notice: In order to avoid linking error, you do have to implement freeMemory even if you don't want to get the bonus points. In this case, just write an empty function like this:123 void freeMemory(Memory *memory, int start, int length) {/* to do */}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 169,
        "WA": 1102
    },
    {
        "id": 270,
        "title": "A Simple BASIC Interpreter",
        "description": " Write a simple BASIC interpreter. A simple basic program has two parts -- a variable declaration part and a statement part. The variable declaration part is always the first line (line 0) in the program. It has all the variable declaration and their initial values, and ends with \"END\". For example the following is an example of variable declaration part. It declares 8 variables and gives them initial values. N = 2 F = 2 ONE = 1 TWO = 2 R = 0 S = 0 ZERO = 0 HUNDRED = 100 END The rest of a simple BASIC program is the statement part, starting with line 1. Each line is a statement. There are five possible statements. A GOTO statement transfers controls to another line. For example, the following command transfers control to line 1. GOTO 1 An IF statement transfers control to another line if the condition is true, or to the next line if the condition is not true. For example the following command transfer control to line 11 if N is greater than HUNDRED. The condition can only take the form of \"variable1 op variable2\", where variable1 and variable2 are two variables and op is \"==\", \"!=\", \">\", \"<\", \">=\", or \"<=\". IF N > HUNDRED GOTO 11 An assignment statement assign an expression to a variable. For example the following statement assigns N with the sum of N and ONE. The expression can only take the form of \"variable1 op variable2\", where variable1 and variable2 are two variables and op is \"+\", \"-\", \"*\", \"/\", or \"%\". N = N + ONE A PRINT statement prints the value of a variable and a new line. For example the following statement prints the value of N in a line. PRINT N A STOP statement stops the execution of the simple BASIC program. Limits Lengths of variables are between 1 to 7. There are at most 100 variables and 1000 lines in the program. A variable name consists of uppercase letters and/or digits. Input There input is a simple BASIC program. Output The output is the results of all PRINT statements.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "N = 2 F = 2 ONE = 1 TWO = 2 R = 0 S = 0 ZERO = 0 HUNDRED = 100 END\nIF N > HUNDRED GOTO 11\nF = TWO + ZERO\nR = N % F\nIF R == ZERO GOTO 9\nF = F + ONE\nS = F * F\nIF S <= N GOTO 3\nPRINT N\nN = N + ONE\nGOTO 1\nSTOP\n"
        ],
        "sampleOutput": [
            "3\n5\n7\n11\n13\n17\n19\n23\n29\n31\n37\n41\n43\n47\n53\n59\n61\n67\n71\n73\n79\n83\n89\n97\nNOTES\nFirst you need to prepare two arrays -- one for the names of the variables and the second for the current values of the variables. After processing the first line you will know all the names and intial values of all variables.\nNext you need to process and store every BASIC program statement because you may need to go to any line number. You can use a array to store what kind of statement each line is. And in addition for a GOTO statement you need to remember which line it will go, and for an assignment you need to remember the target of the assignment, the operands and the operator of the expression, etc.\nAfter you have process all the statement, you can just set line number to 1 and start doing each statement, according to the information stored in the previous step.\n"
        ],
        "hint": "",
        "AC": 303,
        "WA": 465
    },
    {
        "id": 271,
        "title": "Multiply Polynomials",
        "description": " Write a program to multiply two polynomials. We will represent a polynomial by a sequence of its coefficients. For example, we will use (1,2,3) to represent x2+2x+3, and (4,5,6,7) for 4x3+5x2+6x+7. Limits The number of coefficients in a polynomial is no more than 100. The coefficients are positive and no more than 100. Input There are four lines in the input. The first line is a positive integer n, the number of coefficients of the first polynomial f(x). The second line has m integers for the coefficients of the second polynomial g(x). Similarly, the third line and fourth line are for the second polynomial. Output The output is the coefficients of the product of the two input polynomials f(x)g(x).",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "3\n1 2 3\n4\n4 5 6 7\n"
        ],
        "sampleOutput": [
            "4 13 28 34 32 21\n"
        ],
        "hint": "",
        "AC": 834,
        "WA": 1002
    },
    {
        "id": 275,
        "title": "Set",
        "description": " Build a library to process set of numbers from 0 to 63 Since a long long int has 64 bits, we can use a bit to present a number in the set. If the bit is 1 then the corresponding number is in the set, otherwise it is not in the set. You need to implement the following functions for set. void init(Set *set) This function set the set to be empty. void add(Set *set, int i) This function adds i into the set. void has(Set set, int i) This function prints a message to indicate if i is in a set. For example, if a is {3,5,2} and i is 3, then it will print set has 3. If a is {3,5,2} and i is 13, then it will print set does not have 13. Set setUnion(Set a, Set b) This function returns the union of sets a and b. For example, if a is {3,5,2} and b is {3,7,9}, then the union of a and b is {3,5,2,7,9}. Set setIntersect(Set a, Set b) This function returns the intersection of sets a and b. For example, if a is {3,5,2} and b is {3,7,9}, then the intersection of a and b is {3}. Set setDifference(Set a, Set b) This function returns the difference between sets a and b. For example, if a is {3,5,2} and b is {3,7,9}, then the difference of a and b is {5,2,7,9}. main.c12345678910111213141516171819202122232425262728293031323334353637383940#include <stdio.h>#include \"set.h\"int main(){Set a, b, c;init(&a);add(&a, 3);add(&a, 5);add(&a, 2);init(&b);add(&b, 3);add(&b, 7);add(&b, 9);c = setUnion(a, b);has(c, 2);has(c, 3);has(c, 5);has(c, 7);has(c, 9);c = setIntersect(a, b);has(c, 2);has(c, 3);has(c, 5);has(c, 7);has(c, 9);c = setDifference(a, b);has(c, 2);has(c, 3);has(c, 5);has(c, 7);has(c, 9);return 0;} set.h1234567 typedef unsigned long long Set; void init(Set *set); void add(Set *set, int i); void has(Set set, int i); Set setUnion(Set a, Set b); Set setIntersect(Set a, Set b); Set setDifference(Set a, Set b);",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [
            "set has 2\nset has 3\nset has 5\nset has 7\nset has 9\nset does not have 2\nset has 3\nset does not have 5\nset does not have 7\nset does not have 9\nset has 2\nset does not have 3\nset has 5\nset has 7\nset has 9\n"
        ],
        "hint": "",
        "AC": 733,
        "WA": 1555
    },
    {
        "id": 276,
        "title": "Abbreviation",
        "description": " Write a program to extract abbreviations from input. For example, if you are given three strings \"national\", \"taiwan\", \"university\", you must answer \"NTU\". Note that there are four words that will not appear in the abbreviation - \"of\", \"and\", \"the\", and \"at\". For example, \"the\", \"united\", \"states\", \"of\", \"america\", will become \"USA\". Input The input is a sequence of words consisting of lowercase letters and periods only. A set of words to form an abbreviation must ends with the last word having a '.' (period) at the end. For the previous \"NTU\" example, you will have \"national\" \"taiwan\", then \"university.\". Please note that there is a period '.' at the end of \"university\". You must process all inputs until EOF. The last word of the input is guaranteed to have an ending '.'. It is also guaranteed that all abbreviations will have at least one character. Output You must output all abbreviations from the input, one per line. Limits The number of characters in a word including the ending period is no more than 127. The length of an abbreviation is no more than 127.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "the united states of american. taiwan high speed rail. national\ntaiwan university. metropolitan rapid transit. north atlantic treaty\norganization. european union. united kingdom. national chiao tong\nuniversity. university of hong kong. massachusetts institute of\ntechnology. university of california at san diego. national\naeronautics and space administration. immigration and naturalization\nservice.\n"
        ],
        "sampleOutput": [
            "USA\nTHSR\nNTU\nMRT\nNATO\nEU\nUK\nNCTU\nUHK\nMIT\nUCSD\nNASA\nINS\n"
        ],
        "hint": "",
        "AC": 717,
        "WA": 1577
    },
    {
        "id": 277,
        "title": "Digits",
        "description": " Write a program to print digits from 0 to 9. An 6 by 9 font is illustrated here. Note that all digits can be represented by the 7 segments -- three horizontal and four vertical. The middle horizontal segment will be in the middle of the height, and the height is guaranteed to be an odd number, like 9 we have here. Also notice that there is a vertical spacing between this digit and the next one. The dark squares will be printed with the digit, and the white space will be printed as ASCII space ' '. p277. 7 segments Input Each line of the input has the string of digits, the width of the font, then the height of the font. You must process all data until EOF. Output The output is the 7-segment form of all digits in the string. Limits The length of the string is no more than 10. The width of the font is between 4 and 9. The height is between 5 and 15, and must be an odd number.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "0123456789 6 9\n8888 8 11\n"
        ],
        "sampleOutput": [
            "// 請忽略這一行，只是為了下一行對齊得格式，內部問題尚未解決。   \n 000         222   333         555   666   777   888   999\n0   0     1     2     3 4   4 5     6     7   7 8   8 9   9\n0   0     1     2     3 4   4 5     6     7   7 8   8 9   9\n0   0     1     2     3 4   4 5     6     7   7 8   8 9   9\n             222   333   444   555   666         888   999\n0   0     1 2         3     4     5 6   6     7 8   8     9\n0   0     1 2         3     4     5 6   6     7 8   8     9\n0   0     1 2         3     4     5 6   6     7 8   8     9\n 000         222   333         555   666         888\n 88888   88888   88888   88888\n8     8 8     8 8     8 8     8\n8     8 8     8 8     8 8     8\n8     8 8     8 8     8 8     8\n8     8 8     8 8     8 8     8\n 88888   88888   88888   88888\n8     8 8     8 8     8 8     8\n8     8 8     8 8     8 8     8\n8     8 8     8 8     8 8     8\n8     8 8     8 8     8 8     8\n 88888   88888   88888   88888\n"
        ],
        "hint": "",
        "AC": 574,
        "WA": 1000
    },
    {
        "id": 281,
        "title": "Number of 1s",
        "description": " Write a program to compute the number of 1's in their binary representation. For example 7 has three 1's since its binary representation is 00000111. 25 also has three ones because its binary representation is 00011001. Input A set of positive integers no more than 2147483647, one per line. You must process them until EOF. Output The number of 1's in the binary representation of the input integer, one per line.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1\n3\n5\n7\n127\n2147483647\n"
        ],
        "sampleOutput": [
            "1\n2\n2\n3\n7\n31\n"
        ],
        "hint": "",
        "AC": 993,
        "WA": 266
    },
    {
        "id": 282,
        "title": "Maximum number of 1s for long long",
        "description": " Write a program to compute the number of 1's in their binary representation. For example 7 has three 1's since its binary representation is 00000111. 25 also has three ones because its binary representation is 00011001. Input A set of positive integers no more than 9223372036854775807, one per line. You must process them until EOF. Output The number of 1's in the binary representation of the input integer, one per line.",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1\n3\n5\n7\n127\n2147483647\n9223372036854775807\n"
        ],
        "sampleOutput": [
            "1\n2\n2\n3\n7\n31\n63\n"
        ],
        "hint": "",
        "AC": 860,
        "WA": 492
    },
    {
        "id": 283,
        "title": "Chicken, Rabbit, and Crab in a Cage",
        "description": " 寫一個程式來解決一下問題。 有雞、兔子和螃蟹在同一個籠子裡。 現給定這些動物的總數 (s)、動物腳的總數 (f) 及動物尾巴的總數 (t)， (0≤s,f,t≤231−1) 請計算雞、兔子、螃蟹的數量。 給定的數字保證有解。",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "9 48 5\n"
        ],
        "sampleOutput": [
            "2\n3\n4\n"
        ],
        "hint": "",
        "AC": 1557,
        "WA": 483
    },
    {
        "id": 10005,
        "title": "Parse Integer",
        "description": " 從一段英數夾雜的字串中，擷取整數輸出。",
        "inputFormat": " 有多組測資，每組測資一行，字串長度不超過 1000，出現的整數 x 滿足 −231≤x≤231−1",
        "outputFormat": " 將每一個整數輸出一行。",
        "sampleInput": [
            "P0C002NTUCSIE2015Week2EXAMPROBLEM1\n"
        ],
        "sampleOutput": [
            "0\n2\n2015\n2\n1\n"
        ],
        "hint": "#include <stdio.h>\n#include <string.h>    // strlen(s)\n int main() {\n    char s[1024];\n    while (scanf(\"%s\", s) == 1) {\n        int n = (int) strlen(s);    // strlen(\"CSIE\") = 4, actually use \"CSIE\\0\" in memory.\n        for (int i = 0; i < n; i++) {\n            char c = s[i];   \n            /*\n                input \"CSIE\",\n                s[0] = 'C', s[1] = 'S', ...\n            */\n            /* add you code here */\n        }\n        /* add you code here */\n    }\n    return 0;\n}\n多組測資 意即一個測資檔案會有多個測資。\nP0C002NTUCSIE2015Week2EXAMPROBLEM1\n2015Y09M20D02PM\n",
        "AC": 371,
        "WA": 368
    },
    {
        "id": 10006,
        "title": "Sum of Integers",
        "description": " 將輸入的數字加總起來，讀到 EOF (End-of-File) 後輸出總和。",
        "inputFormat": " 每個整數 x 滿足 −231≤x≤231−1，總和保證在 sign-32bit 內。",
        "outputFormat": " 將每一個整數輸出一行。",
        "sampleInput": [
            "2015\n9\n20\n"
        ],
        "sampleOutput": [
            "2044\n"
        ],
        "hint": "如何本機測試？打開執行檔，手動輸入完後按下 Ctrl + Z + Enter 或者直接使用 ./a.out <test.in 測試。\n",
        "AC": 451,
        "WA": 72
    },
    {
        "id": 10007,
        "title": "Count of Segments",
        "description": " 給 N 個 0/1 整數的序列，請問有多少連續片段。",
        "inputFormat": " 輸入有多組測資，每一組第一行會有一個整數 N，第二行會有 N 個 0/1 整數。",
        "outputFormat": " 對於每組測資，輸出一行片段個數。",
        "sampleInput": [
            "7\n0 1 1 0 0 0 1\n"
        ],
        "sampleOutput": [
            "4\n"
        ],
        "hint": "0 1 1 0 0 0 1\n^ --- ^^^^^ -\n共計四段。\n多組測資 意即一個測資檔案會有多個測資。\n7\n0 1 1 0 0 0 1\n3\n1 1 1\n",
        "AC": 407,
        "WA": 96
    },
    {
        "id": 10008,
        "title": "Coins and Paper Moneny",
        "description": " 收銀機只有 1000, 500, 100, 50, 10, 5, 1 這 7 種面值的紙鈔和硬幣，最小化所有面值的數量。",
        "inputFormat": " 輸入有多組測資，每一組只會有一個整數 N，滿足0≤N≤231−1。",
        "outputFormat": " 對於每一組測資輸出一行七個整數，分別為 1000, 500, 100, 50, 10, 5, 1 的數量。",
        "sampleInput": [
            "1234\n"
        ],
        "sampleOutput": [
            "1 0 2 0 3 0 4\n"
        ],
        "hint": "多組測資 意即一個測資檔案會有多個測資。\n1234\n5678\n10\n",
        "AC": 366,
        "WA": 284
    },
    {
        "id": 10009,
        "title": "Reduce a Fraction",
        "description": " 將一個分數化簡到最簡分數。",
        "inputFormat": " 輸入有多組測資，每一組一行兩個整數 a,b。80 pt. 0≤a≤1000, ≤b≤100020 pt. 109≤a≤2×109, 109≤b≤2×109",
        "outputFormat": " 對於每組測資輸出一行 x / y。",
        "sampleInput": [
            "60 80\n"
        ],
        "sampleOutput": [
            "3 / 4\n"
        ],
        "hint": "AC 者，請寫一份程式只拿 80 分 TLE 試試，體驗一下 時間複雜度 的問題。\n多組測資 意即一個測資檔案會有多個測資。\n60 80\n50 100\n0 40\n",
        "AC": 359,
        "WA": 351
    },
    {
        "id": 10010,
        "title": "Conquering cities and towns",
        "description": "",
        "inputFormat": " 只有一組測資，測資第一行會有一個整數 N,M。 接下來會有一個整數 Q，表示接下來會有 Q 行詢問。 對於每一行詢問有四個整數 lx,ly,rx,ry，表示矩形的左上角點、右下角點座標。1≤N,M≤10001≤Q≤100001≤lx,rx≤N1≤ly,ry≤M",
        "outputFormat": " 對於每個詢問輸出一行，第一個數字表示有多少資源個數 S，接下來有 S 個座標按照字典順序輸出。",
        "sampleInput": [
            "5 4\n3\n2 2 3 3\n2 3 4 4\n3 3 4 4\n"
        ],
        "sampleOutput": [
            "4 (2, 2) (2, 3) (3, 2) (3, 3)\n4 (2, 4) (3, 4) (4, 3) (4, 4)\n0\n"
        ],
        "hint": "",
        "AC": 265,
        "WA": 481
    },
    {
        "id": 10011,
        "title": "Move Zeroes",
        "description": "",
        "inputFormat": " 輸入只有一組測資，每一組第一行會有一個整數 n，接下來會有 n 個整數 Ai。",
        "outputFormat": " 輸出 n 個整數以空白隔開。",
        "sampleInput": [
            "5\n0 1 0 3 12\n"
        ],
        "sampleOutput": [
            "1 3 12 0 0\nBonus\n如果一開始把數字存在陣列中，如何使用 O(1)\n來完成呢？在算法中命名為 in-place algorithm。\n#include <stdio.h>\n#define MAXN 100005\nint A[MAXN];\nint main() {\n    int n, i;\n    while (scanf(\"%d\", &n) == 1) {\n        for (i = 0; i < n; i++)\n            scanf(\"%d\", &A[i]);\n        /* add your code */\n        for (i = 0; i < n; i++)\n            printf(\"%d%c\", A[i], \" \\n\"[i==n-1]);\n    }\n    return 0;\n}\n"
        ],
        "hint": "",
        "AC": 355,
        "WA": 307
    },
    {
        "id": 10016,
        "title": "Structure - Fraction",
        "description": " 題目描述 分別實作分數約分、加減乘除五個函數。 系統會自動加入 main.c，只需要上傳 fraction.h 和 fraction.c 即可。 本地編譯參數為 gcc main.c fraction.c -std=c99 -O2 若使用 Dev-C++ 的同學，可以利用 Tools > Compile Options > General > 勾選 Add the following commands when calling the linker: -static-libgcc -std=c99 fraction.c main.c123456789101112131415161718192021#include <stdio.h>#include \"fraction.h\"int main() {int cmd, x, y, z, w;Frac a, b, c;scanf(\"%d\", &cmd);scanf(\"%d %d %d %d\", &x, &y, &z, &w);a = normal(x, y), b = normal(z, w);if (cmd == 1) {c = add(a, b);} else if (cmd == 2) {c = subtract(a, b);} else if (cmd == 3) {c = multipy(a, b);} else if (cmd == 4) {c = divide(a, b);}printf(\"%lld / %lld\\n\", c.a, c.b);return 0;} fraction.h12345678 typedef struct {long long a, b;} Frac; Frac normal(long long, long long); Frac add(Frac, Frac); Frac subtract(Frac, Frac); Frac multipy(Frac, Frac); Frac divide(Frac, Frac); fraction.c1234567891011121314151617#include \"fraction.h\"Frac normal(long long a, long long b) {/* add your code */} Frac add(Frac x, Frac y) {/* add your code */} Frac subtract(Frac x, Frac y) {/* add your code */} Frac multipy(Frac x, Frac y) {/* add your code */} Frac divide(Frac x, Frac y) {/* add your code */}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1\n0 1 50 30\n"
        ],
        "sampleOutput": [
            "5 / 3\n"
        ],
        "hint": "",
        "AC": 218,
        "WA": 282
    },
    {
        "id": 10017,
        "title": "Fast Dynamic Nearest Neighbors Search",
        "description": " 背景 動畫 遊戲人生《No Game No Life》中，史蒂芙 (Stephanie Dola) 常常被欺負，儘管她以學院第一畢業，對於遊戲一竅不通的她在這個世界常常被欺負。現在就交給你來幫幫她。 問題描述 兩個人輪流在一個大棋盤上下棋，每一步棋的得分根據這一步棋與最鄰近的敵方棋子的曼哈頓距離。 對於兩個點 p,q 座標 (px,py),(qx,qy)，曼哈頓距離 (Manhattan distance) 為 |px−qx|+|py−qy|。",
        "inputFormat": " 每組測資只有一筆，第一行一個整數 N，表示兩方輪流下 N 步棋。接下來會有 2N 行，奇數行為玩家史蒂芙下棋的座標，偶數行為玩家空下棋的座標。1≤N≤50000 棋座標 (x,y)，範圍 0≤x,y≤32767 保證每一個座標最多只會有其中一方的棋子",
        "outputFormat": " 除了先手的第一步，每一步都找到最鄰近敵方旗子的曼哈頓距離。",
        "sampleInput": [
            "3\n1 1\n5 5\n4 4\n3 2\n2 4\n2 3\n",
            "+--------------+     +--------------+     +--------------+     +--------------+     +--------------+     +--------------+  \n|A1|  |  |  |  |     |A1|  |  |  |  |     |A1|  |  |  |  |     |A1|  |  |  |  |     |A1|  |  |  |  |     |A1|  |  |  |  |  \n+--------------+     +--------------+     +--------------+     +--------------+     +--------------+     +--------------+  \n|  |  |  |  |  |     |  |  |  |  |  |     |  |  |  |  |  |     |  |  |  |  |  |     |  |  |  |A3|  |     |  |  |B3|A3|  |  \n+--------------+     +--------------+     +--------------+     +--------------+     +--------------+     +--------------+  \n|  |  |  |  |  | +-> |  |  |  |  |  | +-> |  |  |  |  |  | +-> |  |B2|  |  |  | +-> |  |B2|  |  |  | +-> |  |B2|  |  |  |  \n+--------------+     +--------------+     +--------------+     +--------------+     +--------------+     +--------------+  \n|  |  |  |  |  |     |  |  |  |  |  |     |  |  |  |A2|  |     |  |  |  |A2|  |     |  |  |  |A2|  |     |  |  |  |A2|  |  \n+--------------+     +--------------+     +--------------+     +--------------+     +--------------+     +--------------+  \n|  |  |  |  |  |     |  |  |  |  |B1|     |  |  |  |  |B1|     |  |  |  |  |B1|     |  |  |  |  |B1|     |  |  |  |  |B1|  \n+--------------+     +--------------+     +--------------+     +--------------+     +--------------+     +--------------+\n"
        ],
        "sampleOutput": [
            "8\n2\n3\n3\n1\n"
        ],
        "hint": "",
        "AC": 142,
        "WA": 134
    },
    {
        "id": 10018,
        "title": "Find a Duplicate Number",
        "description": " 給 N 個整數的序列，每個整數都介於 1 到 N−1 之間，根據鴿籠原理保證至少一個數字重複，請輸出重複的那一個數字。若有多個答案，任意一個都可以被接受。",
        "inputFormat": " 輸入第一行會有一個整數 N，第二行會有 N 個整數介於 1 到 N−1 之間。1≤N≤100000",
        "outputFormat": " 對於每一組測資，輸出一行一個整數 x，表示 x 在序列中出現至少 2 次的整數。",
        "sampleInput": [
            "5\n1 1 2 2 3\n"
        ],
        "sampleOutput": [
            "2\n"
        ],
        "hint": "",
        "AC": 315,
        "WA": 149
    },
    {
        "id": 10019,
        "title": "String Trim",
        "description": " 將一個字串的首尾空白移除後輸出。",
        "inputFormat": " 每一行會有一個字串 S 且 |S|≤100。",
        "outputFormat": " 對每一個字串 S 移除首尾空白後輸出。",
        "sampleInput": [
            "1 2 3\n      Presentation Error\n"
        ],
        "sampleOutput": [
            "1 2 3\nPresentation Error\n測試 Presentation Error Judge\n測試完畢！現在應該是正常的，空白字元 whitespace (不只有 ' ' 為空白字元)，請利用 #include <ctype.h> 中的 isspace() 取代 s[i] == ' ' 的使用。\n"
        ],
        "hint": "",
        "AC": 678,
        "WA": 1538
    },
    {
        "id": 10020,
        "title": "Tricky Quadratic Function",
        "description": " 給一個 f(x)=ax2+bx+c，保證一定有兩個根，找到兩個根並且先輸出小的。",
        "inputFormat": " 多組測資，每組測資一行三個浮點數 a,b,c，表示 f(x)=ax2+bx+c。",
        "outputFormat": " 對於每組測資輸出一行，每一個根保留小數點後 20 位，使用 printf(\"%.20lf\\n\", f); 或者 printf(\"%.20f\\n\", f);",
        "sampleInput": [
            "1 -10.5 27\n1 -10 21\n"
        ],
        "sampleOutput": [
            "4.50000000000000000000 6.00000000000000000000\n3.00000000000000000000 7.00000000000000000000\n"
        ],
        "hint": "AC 啊，就像運氣，不必強求。測試編譯器環境用途 ... wiki Loss of significance\n",
        "AC": 255,
        "WA": 250
    },
    {
        "id": 10021,
        "title": "Walking on the Safe Side",
        "description": " 給一個 N×M 網格，要從左上角走到右下角，每一步只能往下或往右，有些格子有障礙物，無法經過障礙物的格子，請問有多少種方法數。",
        "inputFormat": " 有多組測資，每一組第一行會有兩個整數 N,M，接下來會有 N 行，每一行上會有 M 個整數，表示座標 (i,j) 上是否有障礙物，用 1 表示有障礙物。1≤N,M≤100",
        "outputFormat": " 每一組測資輸出一行，輸出方法數 Smod10000 的結果。",
        "sampleInput": [
            "5 5\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n6 5\n0 0 0 0 0\n0 1 0 1 0\n0 1 1 1 0\n0 0 1 1 0\n0 1 1 0 0\n0 0 0 0 0\n6 5\n0 0 0 0 0\n0 1 0 1 0\n0 1 0 1 0\n0 0 0 1 0\n0 1 0 0 0\n0 0 0 0 0\n"
        ],
        "sampleOutput": [
            "70\n2\n8\n"
        ],
        "hint": "高中排列組合之填表計數\n",
        "AC": 248,
        "WA": 600
    },
    {
        "id": 10029,
        "title": "Where is My Life",
        "description": " 有 M 道題目，每題沒有標示配分，考試不倒扣，考試成績為所有答對題目的配分總和。 現在已知 N 個人答對的題目和總成績，請推論某一個人的成績為何。",
        "inputFormat": " 輸入有多組測資。 每一組測資第一行會有兩個整數 N,M，分別表示有 N 個人和 M 道題目。 接著會有 N 行，每一行上會有 M+1 個整數，在第 n 行上的前 i(1≤i≤M) 個整數 An,i 表示第 n 個人是否答對第 i 道題目，An,i=1 表示答對，反之 An,i=0 表示答錯，最後一個整數為第 n 個人的總成績 Sn。 最後一行上有 M 個整數，表示某一個人的答對題目情況。 Limit1≤N≤1001≤M≤1000≤Sn≤100",
        "outputFormat": " 對每一組測資，推論出詢問的答題總成績，若發生輸入本身矛盾，則輸出 contradictory，如果無法推斷出唯一解則輸出 not sure，反之輸出四捨五入到整數的成績。",
        "sampleInput": [
            "3 5\n1 0 1 0 0 40\n0 1 0 1 0 60\n1 0 1 1 0 80\n0 1 0 0 0\n 3 5\n1 0 1 0 0 40\n0 1 0 1 0 60\n1 0 1 1 0 80\n0 0 0 0 0\n 3 5\n1 0 1 0 0 40\n0 1 0 1 0 60\n1 0 1 1 0 80\n0 0 1 0 0\n 3 2\n1 0 50\n0 1 50\n1 0 40\n1 1\nSample Ouput\n20\n0\nnot sure\ncontradictory\nNotice\n大一這麼強，Morris 覺得人生白活好一陣子。\n"
        ],
        "sampleOutput": [],
        "hint": "",
        "AC": 59,
        "WA": 198
    },
    {
        "id": 10030,
        "title": "Real Fake Thing",
        "description": "「偽物比真物更有價值」—貝木泥舟 「真物和偽物一樣有價值」—忍野咩咩 「偽娘比真娘更有價值」—精英島民 任兩個物品的相似度 sim(A,B)=|A∩B||A∪B|，換句話說把 A 具有的特徵和 B 具有的特徵類型取交集、聯集個數，相除就能得到其相似度。例如有 5 個特徵，若 A 表示成 11001、B 表示成 01100，sim(A,B)=|2||1,2,3,5|=0.25。 現在盤面上有 N 個物品、M 種特徵，請問相似度大於等於 0.8 的相似對數 S 有多少種。為了讓這一題更有趣味，算法允許偽物，輸出 S N(N−1)/2×100%。",
        "inputFormat": " 每組測資，第一行會有兩個整數 N,M，表示有 N 個物品、M 種特徵。 接下來會有 N 行，每一行上會有 M 個 01 字符，第 i 行上的第 j 個字元，表示第 i 個物品，是否擁有特徵 j。1<N≤1024,0<M≤512",
        "outputFormat": " 對於每一組輸出一行，輸出一個小數點兩位，相似度高於 0.8 的對數 / 總對數的百分比。",
        "sampleInput": [
            "8 10\n0111101101\n0111101100\n0111101100\n0111101101\n1100101010\n0111101100\n0111101100\n0011101111\n 8 10\n1111101100\n1011101100\n1010101100\n1010111010\n0100110100\n1011101100\n1110110000\n1011111100\n"
        ],
        "sampleOutput": [
            "53.57\n25.00\n"
        ],
        "hint": "bitset / bitmask\n",
        "AC": 125,
        "WA": 486
    },
    {
        "id": 10031,
        "title": "Fast 64-bits Modular Arithmetic",
        "description": " ab≡xmodn 已知 a,b,n，求出 x。",
        "inputFormat": " 有多組測資，每一組測資一行三個整數 a,b,n，其中 0≤a,b≤1018,1≤n≤1018。",
        "outputFormat": " 對於每一組測資輸出一行，abmodn 的結果。",
        "sampleInput": [
            "3 5 7\n2 4 3\n2 0 2\n5 1 4\n"
        ],
        "sampleOutput": [
            "1\n2\n0\n1\n"
        ],
        "hint": "Wiki Modular arithmetic 答案在裡頭\n",
        "AC": 145,
        "WA": 370
    },
    {
        "id": 10032,
        "title": "String Subset",
        "description": " 給予一個字串 S S，求出所有子字串的集合，將集合內除了空字串以外的字串照字典順序輸出。",
        "inputFormat": " 只有一組測資，測資一行一個字串 S S，只由大寫字母組成，長度小於等於 500。",
        "outputFormat": " 對於每一組測資，子字串集合按照字典順序印出。",
        "sampleInput": [
            "SLEEP\n"
        ],
        "sampleOutput": [
            "E\nEE\nEEP\nEP\nL\nLE\nLEE\nLEEP\nP\nS\nSL\nSLE\nSLEE\nSLEEP\n"
        ],
        "hint": "排序 or 其他\n",
        "AC": 305,
        "WA": 352
    },
    {
        "id": 10039,
        "title": "Baby Boos",
        "description": " 嬰兒的話語總是相當難理解，身為父母每天記錄嬰兒所說的話，但隨著成長，之前念過的字可能是錯誤的，例如誤把字母 'B' 發音成 'D'。現在完全沒更動下的日記中找到這一段時間所講的話，接著會有 N N 行表示某一天發現字母被誤認的情況。",
        "inputFormat": " 輸入的第一行會有一個大寫字母構成的字串 S S，下一行會有一個整數 N N，表示接下來要執行 N N 行的替換規則，接下來的 N N 行，每一行上有兩個大寫字母 u,v u 表示要將字母 v v 轉換成字母 u u。1≤|S|≤10000011≤N≤1000001",
        "outputFormat": " 輸出一行，顯示最後的替換結果。",
        "sampleInput": [
            "AABBCCD\n3\nA B\nB C\nC A\n"
        ],
        "sampleOutput": [
            "CCCCBBD\n"
        ],
        "hint": "",
        "AC": 209,
        "WA": 376
    },
    {
        "id": 10040,
        "title": "Dictionary & Substring",
        "description": " 給一個字典，字典裡總共 N 個單字，每個單字長度不超過 50，接著詢問 Q 次，對於每一組詢問 S，輸出字典裡有多少個單字存在 S∈Wordi.substring()。",
        "inputFormat": " 輸入一行會有一個整數 N，表示接下來字典裡的 N 個單字，接著會有 N 行表示字典單字，接著會有一行一個整數 Q，表示接下來有 Q 組詢問，每一組詢問一行 S。 N≤200 Q≤50",
        "outputFormat": " 對於每一組詢問，輸出有多少單詞存在子字串恰好為 S。",
        "sampleInput": [
            "4\nmoemoeta\nstephen\nyoooo\nphew\n4\nmoe\no\nph\noo\n"
        ],
        "sampleOutput": [
            "1\n2\n2\n1\n注意事項\nMorris 回老家一趟，暫時無法回應。\n"
        ],
        "hint": "",
        "AC": 162,
        "WA": 48
    },
    {
        "id": 10043,
        "title": "Advanced Function Pointer",
        "description": " 學會 function 和 pointer 之後，總要來點 function pointer 才行。你的目標要完成 myint.c 中三個函數。在 madd()、msub()、getmyheart() 三個函數中，其中 madd() 和 msub() 只需要完成兩個整數的加法和減法即可。而在 getmyheart() 中，你必須將 myint.c 函數封裝到 int (*FUNC[])(int, int) 函數指標陣列。 特別注意 getmyheart() 的前兩行 secret();、test_heart(); 不需要更動，用來輸出 Morris 的秘密以及測試你寫的 madd() 和 msub 的函數是否正確。Morris 藏在 singletest.c 的秘密不需理會。 AC 的通關密語當然要讓 Morris 說出秘密！ main.c12345678910111213141516171819202122232425#include <stdio.h>#include <assert.h>#include \"myint.h\"int madd(int a, int b) {return a + b;} int msub(int a, int b) {return a - b;}int main() {int (*FUNC[8])(int, int);int ret = getmyheart(FUNC);int a, b;scanf(\"%d %d\", &a, &b);printf(\"#function = %d\\n\", ret);printf(\"test function add\\n\");assert(FUNC[0](a, b) == madd(a, b));printf(\"test function sub\\n\");assert(FUNC[1](a, b) == msub(a, b));return 0;} myint.h1234567#ifndef MYINT_H#define MYINT_Hint getmyheart(int (*FUNC[])(int, int)); static int madd(int a, int b); static int msub(int a, int b);#endif myint.c123456789101112131415#include \"myint.h\"#include \"singletest.c\"static int madd(int a, int b) {// please match main function} static int msub(int a, int b) {// please match main function} int getmyheart(int (*FUNC[])(int, int)) {secret();test_heart();// set your function into FUNC[0] and FUNC[1]return 2;} singletest.c#include <stdio.h>#include <assert.h>#include \"myint.h\"static void test_heart() {printf(\"run test heart\\n\");// Morris' secret block, don't care about this.}static void secret() {// Morris' secret block, don't care about this.}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [],
        "hint": "",
        "AC": 89,
        "WA": 41
    },
    {
        "id": 10045,
        "title": "Function Invocation",
        "description": " f(x)=⎧⎩⎨ f(x−1)−h(x) f(g(x))−g(x)1if x>h(x)if x<h(x) otherwise f(x)={f(x−1)−h(x) if x>h(x)f(g(x))−g(x) if x< h(y)={−12+h(y−1)−h(y−2)if y<2 otherwise h(y)={−1 if y<22+h(y−1)−h(y−2)otherwise g(z)={ z2−12if z≤2 otherwise g(z)={z2−1 if z≤22otherwise",
        "inputFormat": " 輸入只有一行一個整數−5≤x≤5−",
        "outputFormat": " 輸出一行 f(x) f 的數值",
        "sampleInput": [
            "3\n",
            "-2\n"
        ],
        "sampleOutput": [
            "-1\n",
            "-4\n"
        ],
        "hint": "",
        "AC": 201,
        "WA": 24
    },
    {
        "id": 10046,
        "title": "Derangement",
        "description": " 有 n 位同學，使用大寫字母分別標示為 'A' 到 'Z'。現在將他們排成一列，由於某些同學個性害羞，不想排第一位 ... 等，請把所有方法數列出來。 如 n=3，A 不排 1、B 不排 2，則有以下幾種排法 BAC BCA CAB 方便起見，請按照字典順序輸出。",
        "inputFormat": " 多組測資，每一組第一行會有兩個整數 n,m，表示有 n 位同學和接下來有 m 條規則。接下來 m 行，每一行上會有兩個整數 x,y，表示第 x 位同學不排第 y 個位置。1≤n≤101≤m≤100",
        "outputFormat": " 對於每一組測資，若有 P 種方法數，則輸出 P 行結果。",
        "sampleInput": [
            "3 2\n1 1\n2 2\n 3 3\n1 1\n2 2\n3 1\n"
        ],
        "sampleOutput": [
            "BAC\nBCA\nCAB\nBAC\nBCA\n"
        ],
        "hint": "",
        "AC": 149,
        "WA": 127
    },
    {
        "id": 10049,
        "title": "Gal Game",
        "description": "「話說，剛剛明明說的是合乎聖誕節的商品。這不是 H-GAME 嗎？哪裡有聖誕元素啊！」「嗯，真虧你發現這點啊，但還是有點可惜，這是全齡版，沒有工口哦！」「不管怎麼樣，一點也沒合聖誕節啊。」「雖然你有好好學習許多東西，但對本質上完全沒有理解。」「最近開始覺得有點明白了 …」「那麼就來說明下這個作品吧」「是一年前發售的大人氣美少女遊戲的續篇吧？」「是的，那為什麼你沒有察覺到－『一年前』這句話所包含的意義」「對於期盼著的人那就意味著 … 與戀人時隔一年的再會！」 在 GALGAME 故事發展過程中，青梅竹馬幾乎沒勝過天降女友，但走哪一條線進行發展都是玩 GALGAME 的樂趣。 然而有一款極為糟糕的 GALGAME 的初始方式則是在一開始選定座標下，系統會根據座標找到附近最鄰近少女，並且在隨後的故事情節都會圍繞這名少女。遊戲的地圖設計很簡單，用一個矩形表示，現在已知 N 名少女的所在地 (都在矩形內部)。一開始選定的座標也必須落在矩形內，請問玩哪每個線路機率分布為何？",
        "inputFormat": " 輸入有多組測資。 每組第一行會有三個整數 N,A,B，表示在 [0:A]×[0:B] 地圖中有 N 個已知座標。 接下來會有 N 行，第 i 行上會有兩個整數 x,y，表示第 i 位少女所在的座標 (x,y) 保證不會有重疊的情況。0<N≤8,0<A,B≤10000≤x≤A,0≤y≤B",
        "outputFormat": " 對於每組測資輸出一行，根據輸入順序輸出每一個故事線的百分比機率 (四捨五入到整數)。",
        "sampleInput": [
            "2 5 3\n1 2\n4 2\n 2 5 3\n1 1\n2 2\n 3 5 3\n1 1\n2 2\n4 1\n"
        ],
        "sampleOutput": [
            "Case #1:\n50\n50\nCase #2:\n30\n70\nCase #3:\n29\n31\n40\n範例解釋\n第三組測資示意圖\n機率計算方式：\n可以觸發的面積\n總面積\n"
        ],
        "hint": "蒙地卡羅模擬法 wiki 即可通過，增加取樣點到一定程度就可以通過。\n使用半平面交算法，數學處理需要找中垂線方程式 ... 等。\n如何產生浮點數亂數\n#include <stdlib.h>\n// generate uniformly distributed random numbers in [0 ... 1]\ndouble frandom() {\n    return rand() * 1.f / RAND_MAX;\n}\n別人計程有的內容我們也一定要有，接著創造出別人沒有的。 by 大中國抄襲主義\n",
        "AC": 122,
        "WA": 221
    },
    {
        "id": 10052,
        "title": "Expected Value Syntax Parser",
        "description": " 期望值表達式有兩種規則，如下所示：⟨expr⟩→integer⟨ 直接表示成一個整數，或者⟨expr⟩→(p⟨ expr1⟩⟨ expr2⟩)⟨ 回傳 E(⟨expr⟩)=p×(⟨ expr1⟩+⟨ expr2⟩)+(1−p)×(⟨ expr1⟩−⟨ expr2⟩) E Created with Raphaël 2.1.4 main() read line parser(string expr) expr(0) is a digit return string2int(expr) call parser(P) call parser(expr1) call parser(expr2) return combine result P, expr1, expr2 yes no",
        "inputFormat": " 有多組測資，每組測資一行。",
        "outputFormat": " 對於每組測資計算期望值，四捨五入至小數點第二位。",
        "sampleInput": [
            "7\n(.5 3 9)\n(0.3 2 (1 1 -10))\n(1.0 (1.0 (1.0 -1 -2) (1.0 -1 -2)) (1.0 (1.0 1 2) 2))\n"
        ],
        "sampleOutput": [
            "7.00\n3.00\n5.60\n-1.00\n"
        ],
        "hint": "",
        "AC": 97,
        "WA": 112
    },
    {
        "id": 10053,
        "title": "Row-Column Game",
        "description": " Morris 和他腦中的小伙伴玩遊戲，遊戲在一個 n×n 的盤面中進行，每一格分別有一個數字。 規則說明 玩家輪流從棋盤中取數字 先手只取水平行，後手只取垂直列 遊戲剛開始，先手必須從第一行開始取數 假設先手取 (i,x) 這一格數字，後手必須在 x 列中挑一個數字 (A(?,x))。同樣地，後手若取 (y,x)，則先手必須在 y 行中挑一個數字 (A(y,?))。 被挑過的數字將不能再次被挑選 取得數字總和較多者宣告獲勝 現在請你統計所有玩家挑選的可能，回報先手獲勝、後手獲勝、平手情況的最終盤面個數。",
        "inputFormat": " 每組測資的第一行會有一個 n，接下來會有 n 行，每一行上會有 n 個整數，第 i 行上第 j 個整數表示盤面 A(i,j) 上的數字。1≤n≤4",
        "outputFormat": "",
        "sampleInput": [
            "3\n1 2 3\n4 5 6\n7 8 9\n3\n1 1 1\n1 1 1\n1 1 1\n4\n1 6 9 5\n4 6 5 8\n2 3 5 7\n9 8 6 7\n"
        ],
        "sampleOutput": [
            "48 24 0\n48 0 24\n8222 8222 188\n範例解說\n1 2 3\n4 5 6\n7 8 9\n先手只能在 1, 2, 3 三個挑一個，倘若選 2，則\n1   3\n4 5 6\n7 8 9\n後手只能在 5, 8 兩個中挑一個，倘若選 8，則\n1   3\n4 5 6\n7   9\n先手只能在 7, 9 中挑一個，倘若選 9，則\n1   3\n4 5 6\n7\n後手只能在 3, 6 中挑一個，倘若選 3，則\n1  \n4 5 6\n7\n由於只有一個整數，先手只能選 1，則\n4 5 6\n7\n現在後手有 4, 7 可以選，若後手選擇 7，則\n4 5 6\n先手沒得選，進入中盤計分。先手得分 12=2+9+1\n，後手得分 18=8+3+7\n，宣告後手獲勝。\n"
        ],
        "hint": "",
        "AC": 123,
        "WA": 26
    },
    {
        "id": 10056,
        "title": "Sort Table",
        "description": " 給予數個成績表單，每一個成績表單的欄位個數是變動的。第一個欄位為長度小於等於 31 個字符串表示名字，其他欄位會是一個整數型態 (signed 32-bits) 的成績格式。一個表單最多 128 個成績欄位，最多有 256 個成績記錄。 範例說明 A 表單為 name\\score ex1 ex2 ex3 pangfeng 100 100 99 morris 0 0 100 打印出 A 表單時會給定排序方法 例如按照 (ex1, ex2, ex3) 則表示先按照 ex1 進行降排序，相同時再按照 ex2，再相同最後是 ex3。最後輸出結果即為 pangfeng, 100, 100, 99 morris, 0, 0, 100 例如按照 (ex3, ex1, ex2) 則表示先按照 ex3 進行降排序，相同時再按照 ex1，再相同最後是 ex2。最後輸出結果即為 morris, 0, 0, 100 pangfeng, 100, 100, 99 實作細節 接下來，你需要實作以下三個 function： void init(ExamTable *self, int n); 初始化某個表單且成績欄位恰好 n 個。 void addrow(ExamTable *self, char *name, int score[]); 增加某個表單的資料。 void print(ExamTable *self, int order[]);",
        "inputFormat": " 第一行有一個整數 n 表示有 n 個表單，第二行上有 n 個整數，分別表示 table0, table1, ..., tablen−1 的成績欄位數 #fieldi，第三行會有一個整數 q，表示接下來的操作次數。 接下來的 q 行，每一行一組操作。",
        "outputFormat": "",
        "sampleInput": [
            "2\n3 4\n10\n1 0 pangfeng 100 100 99\n1 0 morris 0 0 100\n2 0 0 1 2\n2 0 2 0 1\n1 1 hank 5 5 6 6\n1 1 scott 5 7 6 6\n1 1 ahmad 5 5 6 7\n2 1 0 1 2 3\n2 1 3 1 2 0\n2 0 2 0 1\n"
        ],
        "sampleOutput": [
            "main.c\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n#include \"pangfeng.h\"\n#include <stdio.h>\n#include <stdlib.h>\n int main() {\n    const int MAXETB = 8;\n    int etb_n, dim_n;\n    int cmds, cmd, tid, score[128], sort_order[128];\n    char sid[32];\n    ExamTable *etb = (ExamTable*) malloc(sizeof(ExamTable)*MAXETB);\n    scanf(\"%d\", &etb_n);\n    for (int i = 0; i < etb_n; i++) {\n        scanf(\"%d\", &dim_n);\n        init(&etb[i], dim_n);\n    }\n    scanf(\"%d\", &cmds);\n    for (int i = 0; i < cmds; i++) {\n        scanf(\"%d %d\", &cmd, &tid);\n        if (cmd == 1) {\n            scanf(\"%s\", sid);\n            for (int j = 0; j < etb[tid].dim_n; j++)\n                scanf(\"%d\", &score[j]);\n            addrow(&etb[tid], sid, score);\n        } else {\n            for (int j = 0; j < etb[tid].dim_n; j++)\n                scanf(\"%d\", &sort_order[j]);\n            print(&etb[tid], sort_order);\n        }\n    }\n    return 0;\n}\n",
            "----- table begin -----\npangfeng, 100, 100, 99\nmorris, 0, 0, 100\n----- end         -----\n----- table begin -----\nmorris, 0, 0, 100\npangfeng, 100, 100, 99\n----- end         -----\n----- table begin -----\nscott, 5, 7, 6, 6\nahmad, 5, 5, 6, 7\nhank, 5, 5, 6, 6\n----- end         -----\n----- table begin -----\nahmad, 5, 5, 6, 7\nscott, 5, 7, 6, 6\nhank, 5, 5, 6, 6\n----- end         -----\n----- table begin -----\nmorris, 0, 0, 100\npangfeng, 100, 100, 99\n----- end         -----\n"
        ],
        "hint": "全部透過實作 function 的輸出和回傳值進行測試，不管你實作的 struct 細節。\n",
        "AC": 119,
        "WA": 264
    },
    {
        "id": 10059,
        "title": "Complex Number",
        "description": " 實作複數加法、減法、乘法。令 i=−1−−−√ i。 main.c1234567891011121314151617181920#include <stdio.h>#include <stdlib.h>#include <string.h>#include \"complex.h\"int main() {complex (*FUNC[])(complex *, complex *) = {complex_add, complex_sub, complex_mul};int cmd;float x, y, p, q;while (scanf(\"%d %f %f %f %f\", &cmd, &x, &y, &p, &q) == 5) {complex *A = (complex *) malloc(sizeof(complex));complex *B = (complex *) malloc(sizeof(complex));init(A, x, y), init(B, p, q);complex C = FUNC[cmd](A, B);complex_print(&C);}return 0;} complex.h12345678910111213#ifndef _COMPLEX_H#define _COMPLEX_H/*define structure complex*/void init(complex *c, float a, float b); void complex_print(complex *x); complex complex_add(complex *x, complex *y); complex complex_sub(complex *x, complex *y); complex complex_mul(complex *x, complex *y);#endif",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [
            "1\n2\n3\n0 3 2 1 4\n1 3 2 1 4\n2 3 2 1 4\n"
        ],
        "sampleOutput": [
            "1\n2\n3\n4.000+6.000i\n2.000-2.000i\n-5.000+14.000i\nprintf format\n1\n2\nfloat a, b;\nprintf(\"%.3f%+.3fi\\n\", a, b);\n"
        ],
        "hint": "",
        "AC": 153,
        "WA": 119
    },
    {
        "id": 10066,
        "title": "Gal Game II",
        "description": "「話說，剛剛明明說的是合乎聖誕節的商品。這不是 H-GAME 嗎？哪裡有聖誕元素啊！」「嗯，真虧你發現這點啊，但還是有點可惜，這是全齡版，沒有工口哦！」「不管怎麼樣，一點也沒合聖誕節啊。」「雖然你有好好學習許多東西，但對本質上完全沒有理解。」「最近開始覺得有點明白了 …」「那麼就來說明下這個作品吧」「是一年前發售的大人氣美少女遊戲的續篇吧？」「是的，那為什麼你沒有察覺到－『一年前』這句話所包含的意義」「對於期盼著的人那就意味著 … 與戀人時隔一年的再會！」 在 GALGAME 故事發展過程中，青梅竹馬幾乎沒勝過天降女友，但走哪一條線進行發展都是玩 GALGAME 的樂趣。 然而有一款極為糟糕的 GALGAME 的初始方式則是在一開始選定座標下，系統會根據座標找到附近最鄰近少女，並且在隨後的故事情節都會圍繞這名少女。遊戲地圖設計用一個三維空間的球體表示，圓心在 (0,0,0)，半徑為 R，現在已知 N 名少女的所在地 (都在球體內部)。一開始選定的座標也必須落在球體內，請問玩哪每個線路機率分布為何？",
        "inputFormat": " 輸入有多組測資。 每組第一行會有兩個整數 R,N，表示在球體半徑，地圖中有 N 個已知座標。 接下來會有 N 行，第 i 行上會有三個整數 x,y,z，表示第 i 位少女所在的座標 (x,y,z) 保證不會有重疊的情況。0<N≤8,0<A,B≤10000≤x≤A,0≤y≤B",
        "outputFormat": " 對於每組測資輸出一行，根據輸入順序輸出每一個故事線的百分比機率 (四捨五入到整數)。",
        "sampleInput": [
            "5 2\n0 0 0\n4 0 0\n"
        ],
        "sampleOutput": [
            "Case #1:\n78\n22\n範例解釋\n機率計算方式：\n可以觸發的體積\n總體積\n"
        ],
        "hint": "蒙地卡羅模擬法 wiki 即可通過，增加取樣點到一定程度就可以通過。\n如何產生浮點數亂數\n#include <stdlib.h>\n// generate uniformly distributed random numbers in [0 ... 1]\ndouble frandom() {\n    return rand() * 1.f / RAND_MAX;\n}\n別人計程有的內容我們也一定要有，接著創造出別人沒有的。 by 大中國抄襲主義\n",
        "AC": 98,
        "WA": 311
    },
    {
        "id": 10069,
        "title": "Build a Binary Search Tree",
        "description": " 二元搜尋樹（Binary Search Tree），也稱二叉搜索樹、有序二元樹（ordered binary tree），排序二元樹（sorted binary tree），是指一棵空樹或者具有下列性質的二元樹： 若任意節點的左子樹不空，則左子樹上所有結點的值均小於它的根結點的值； 任意節點的右子樹不空，則右子樹上所有結點的值均大於它的根結點的值； 任意節點的左、右子樹也分別為二元搜尋樹。 沒有鍵值相等的節點（no duplicate nodes）。1234567 void insert(Node*& root, int data) {if (!root)      root = new Node(data);else if (data < root->data)insert(root->left, data);else if (data > root->data)insert(root->right, data);} 通常一開始學到二元搜尋樹，會先教插入算法，現在的這個問題很簡單，只是稍微要求效率。",
        "inputFormat": " 輸入有多組測資，每一組，第一行有一個數字 N N(0<N<1310720)，接下來會建入 N N 個數字 M M(signed 32-bit) ，沒有數字會重複。",
        "outputFormat": " 對於每一組測資，輸出一行的前序走訪。",
        "sampleInput": [
            "5\n0 1 2 4 3\n5\n0 2 4 1 3\n5\n3 1 4 2 0\n5\n1 4 2 0 3\n5\n0 4 3 2 1\n"
        ],
        "sampleOutput": [
            "0 1 2 4 3\n0 2 1 4 3\n3 1 0 2 4\n1 0 4 2 3\n0 4 3 2 1\n編譯參數\ngcc main.c basic_node.c bst_node.c object.c -std=c99\nmain.c\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n#include <stdio.h>\n#include <stdlib.h>\n #include \"node.h\"\n void dfsPrint(bstNode *u) {\n    if (u == NULL)    return;\n    u->print(u);\n    dfsPrint(u->getLson(u));\n    dfsPrint(u->getRson(u));\n    FREE(bstNode, u);\n}\nvoid demo(bNode *u)  {\n    if (u == NULL)    return;\n    u->print(u);\n    demo(u->getLson(u));\n    demo(u->getRson(u));   \n    FREE(bNode, u);\n}\nint main() {\n/*\n    bNode *t, *u;\n    t = NEW(bNode);\n    u = NEW(bNode);\n    t->setLson(t, u);\n    u->setRson(u, NEW(bNode));\n    demo(t);\n    */\n    int N;\n    while (scanf(\"%d\", &N) == 1 && N) {\n        int *A = (int *) malloc(sizeof(int)*N);\n        for(int i = 0; i < N; i++)\n            scanf(\"%d\", &A[i]);\n        bstNode *root = buildBST(A, N);\n        dfsPrint(root);\n        puts(\"\");\n        free(A);\n    }\n    return 0;\n}\nnode.c\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n#ifndef _NODE_H\n#define _NODE_H\n #include \"object.h\"\n #define NodeMembers(TYPE) \\\n    Object proto; \\\n    int (*init)(struct TYPE*); \\\n    void (*destroy)(struct TYPE*); \\\n    struct TYPE* (*getLson)(struct TYPE*); \\\n    struct TYPE* (*getRson)(struct TYPE*); \\\n    void (*setLson)(struct TYPE*, struct TYPE*); \\\n    void (*setRson)(struct TYPE*, struct TYPE*); \\\n    struct TYPE *lson, *rson; \\\n    void (*print)(struct TYPE*)\n typedef struct bNode {\n    NodeMembers(bNode);\n} bNode;\n typedef struct bstNode {\n    NodeMembers(bstNode);\n    void *extra;\n} bstNode;\n bstNode* buildBST(int A[], int n);\n extern Object bNodeProto;\nextern Object bstNodeProto;\n#endif\nbasic_node.c\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n#include \"node.h\"\n#include <stdio.h>\n bNode* bNode_getLson(bNode *self) {\n    return self->lson;\n}\nbNode* bNode_getRson(bNode *self) {\n    return self->rson;\n}\nvoid bNode_print(bNode *self) {\n    printf(\"%p L %p R %p\\n\", self, self->lson, self->rson);\n}\nvoid bNode_setLson(bNode *self, bNode *u) {\n    self->lson = u;\n}\nvoid bNode_setRson(bNode *self, bNode *u) {\n    self->rson = u;\n}\n int bNode_init(bNode *self) {\n    self->getLson = bNode_getLson;\n    self->getRson = bNode_getRson;\n    self->setLson = bNode_setLson;\n    self->setRson = bNode_setRson;\n    self->print = bNode_print;\n    self->lson = NULL, self->rson = NULL;\n    return 1;\n}\nvoid bNode_destroy(bNode *obj) {\n}\n Object bNodeProto = {\n    .init = bNode_init,\n    .destroy = bNode_destroy\n};\nbst_node.c\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"node.h\"\n bstNode* bstNode_getLson(bstNode *self) {\n    return self->lson;\n}\nbstNode* bstNode_getRson(bstNode *self) {\n    return self->rson;\n}\nvoid bstNode_setLson(bstNode *self, bstNode *u) {\n    self->lson = u;\n}\nvoid bstNode_setRson(bstNode *self, bstNode *u) {\n    self->rson = u;\n}\nvoid bstNode_print(bstNode *self) {\n    printf(\"%d \", *(int *)(self->extra));\n}\n int bstNode_init(bstNode *obj) {\n    obj->getLson = bstNode_getLson;\n    obj->getRson = bstNode_getRson;\n    obj->setLson = bstNode_setLson;\n    obj->setRson = bstNode_setRson;\n    obj->print = bstNode_print;\n    obj->extra = (void *) malloc(sizeof(int));\n    return 1;\n}\nvoid bstNode_destroy(bstNode *obj) {\n    free(obj->extra);\n}\n Object bstNodeProto = {\n    .init = bstNode_init,\n    .destroy = bstNode_destroy\n};\n bstNode* buildBST(int A[], int n) {\n    /* add your code */\n}\nobject.h\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n#ifndef _object_h\n#define _object_h\n typedef struct {\n    int (*init)(void *self);\n    void (*destroy)(void *self);\n} Object;\n int Object_init(void *self);\nvoid Object_destroy(void *self, Object proto);\nvoid *Object_new(int size, Object proto);\n #define NEW(T) Object_new(sizeof(T), T##Proto)\n#define FREE(T, t) Object_destroy(t, T##Proto)\n #endif\nobject.c\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"object.h\"\n#include <assert.h>\n void Object_destroy(void *self, Object proto) {\n    Object *obj = self;\n    if (proto.destroy != NULL)\n        proto.destroy(self);\n    if (obj)\n        free(obj);\n}\nint Object_init(void *self) {\n    return 1;\n}\nvoid *Object_new(int size, Object proto) {\n    if (!proto.init)\n        proto.init = Object_init;\n    if (!proto.destroy)\n        proto.destroy = Object_destroy;\n     Object *el = calloc(1, size);\n    *el = proto;\n     if(!el->init(el)) {\n        el->destroy(el);\n        return NULL;\n    } else {\n        return el;\n    }\n}\n後記\n參考 Learn C The Hard Way\n上述寫法用在 Singleton 比較好，用來寫 node 過於肥大。free() 的時候請特別小心，這會與當初 malloc 一整塊空間一起回收，別總是利用限有的空間配置！\n"
        ],
        "hint": "",
        "AC": 47,
        "WA": 86
    },
    {
        "id": 10078,
        "title": "Matryoshka Doll",
        "description": " 俄羅斯套娃有許多不同的大小，小的可以放置在大的之中，定義結構如下： doll.h12345678910111213#ifndef _DOLL_H#define _DOLL_Htypedef struct Doll {char top, bottom;struct Doll *interior;} Doll;Doll *newDoll(char top, char bottom); void package(Doll *outer, Doll *inter); const char* doll_c_str(Doll *doll);#endif 其中 Doll.top Doll 和 Doll.bottom Doll 蓋子和底座的樣式，用一個字元表示。 Doll *newDoll(char top, char bottom); 初始化一個俄羅斯娃娃，其中蓋子樣式 top、底座樣式 bottom。 void package(Doll *outer, Doll *inter); 將一個小的俄羅斯娃娃放進大的裡面。 const char* doll_c_str(Doll *doll); 將一個俄羅斯娃娃內部訊息用括弧表示法輸出，回傳字串的起始位置。 main.c (test)12345678910111213141516#include \"doll.h\"#include <stdio.h>#include <stdlib.h>#include <string.h>int main() {Doll *dolls[3];dolls[0] = newDoll('<', '~');dolls[1] = newDoll('(', ')');dolls[2] = newDoll('@', '>');package(dolls[1], dolls[2]);package(dolls[0], dolls[1]);printf(\"%s\\n\", doll_c_str(dolls[0]));return 0;}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [
            "<(@>)~\n"
        ],
        "hint": "",
        "AC": 103,
        "WA": 109
    },
    {
        "id": 10079,
        "title": "Tiny Command Tool",
        "description": " 模擬 Linux 環境下的指令。 tct.h12345678910111213#ifndef _TCT_H#define _TCT_Htypedef struct Directory {char name[256];struct Directory *childDir;struct Directory *silbingDir;} Directory;void tree(Directory *fs); Directory* cd(Directory *fs, char path[]);#endif void tree(Directory *fs); Directory* cd(Directory *fs, char path[]); main.c (test)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include \"tct.h\"#include <stdio.h>#include <stdlib.h>#include <stdarg.h>#include <string.h>Directory* mkDir(char name[]) {Directory *d = (Directory *) malloc(sizeof(Directory));strcpy(d->name, name);d->silbingDir = d->childDir = NULL;return d;} Directory* newDir(char name[], int n, ...) {va_list args;va_start(args, n);Directory *u = mkDir(name), *p = NULL;for (int i = 0; i < n; i++) {Directory *para = va_arg(args, Directory*);if (i == 0)u->childDir = para;if (p != NULL)p->silbingDir = para;p = para;}va_end(args);return u;} int main() {Directory *fs =newDir(\"root\", 3,newDir(\"home\", 2,newDir(\"morris\", 1,newDir(\"workspace\", 0)),newDir(\"stephanie\", 0)), newDir(\"etc\", 0), newDir(\"bin\", 2, newDir(\"arch\", 0), newDir(\"cat\", 0)));tree(fs);char path[128] = \"home/morris\";tree(cd(fs, path));tree(fs);return 0;}",
        "inputFormat": "",
        "outputFormat": "",
        "sampleInput": [],
        "sampleOutput": [
            "+- root\n   |\n   +- home\n   |  |\n   |  +- morris\n   |  |  |\n   |  |  +- workspace\n   |  |\n   |  +- stephanie\n   |\n   +- etc\n   |\n   +- bin\n      |\n      +- arch\n      |\n      +- cat\n+- morris\n   |\n   +- workspace\n"
        ],
        "hint": "",
        "AC": 47,
        "WA": 35
    },
    {
        "id": 10118,
        "title": "Make a List",
        "description": " Morris 正在解某一道題，輸入的每一組測資只會需要一個串列 (List)，該筆測資運行結束後便會刪除串列。現在需要請你協助 Morris 建立這一個串列。 utils.h 這部份不需要變動。123456789101112131415#ifndef __UTILS_H#define __UTILS_Hint sp_rand(); void sp_srand(long long t);typedef struct Node {int v;struct Node *next;} Node;void rm_list(Node *head); Node* mk_list(int n);#endif utils.c#include \"utils.h\"static long long seed = 1; int sp_rand() {return (seed = (seed * 9301 + 49297) % 233280);} void sp_srand(long long t) {seed = t;} main.c 這部份不需要變動。123456789101112131415161718192021222324252627#include \"utils.h\"#include <stdio.h>#include <stdlib.h>int main() {int n;long long s;scanf(\"%lld\", &s);sp_srand(s);while (scanf(\"%d\", &n) == 1) {Node *list = mk_list(n);Node *u = list;for (int i = 0; i < n; ) {long long sum = 0;int cnt = 1;while (u && cnt < 100000) {sum += u->v * cnt;u = u->next, cnt++;i++;}printf(\"%lld\\n\", sum);}rm_list(list);}return 0;} list.c123456789101112131415161718#include \"utils.h\"#include <stdio.h>#include <stdlib.h>Node* mk_list(int n) {Node *head;// ...for (int i = 0; i < n; i++) {Node *u;// ...u->v = sp_rand(), u->next = NULL;// ...}return head;} void rm_list(Node *head) {// ...}",
        "inputFormat": " 輸入第一行會有一個亂數種子 S S，接著會有數行，每一行上會有一個整數 N N，請產生一個長度為 N N 個串列。你可以假設 N≤2000000 N，同時串列不會進行刪除操作。",
        "outputFormat": " 輸出串列結果。",
        "sampleInput": [
            "514\n1\n2\n3\n"
        ],
        "sampleOutput": [
            "58598 ->\n127215 -> 79852 ->\n222509 -> 178626 -> 29563 ->\n編譯參數\ngcc -std=c99 -O2 -c list.c\ngcc -std=c99 -O2 -c utils.c\ngcc -std=c99 -O2 list.o utils.o main.c -lm\n"
        ],
        "hint": "",
        "AC": 81,
        "WA": 189
    },
    {
        "id": 50036,
        "title": "Pick up Numbers",
        "description": " Write a program to count the number of ways to pick at least k number out of N positive numbers so that the sum of the picked numbers is no more than M. For example, given four numbers 1, 3, 5, and 7, then there are 6 ways to pick at least 2 numbers so that their sum is no more than 10. The solutions are {1,3},{1,5},{1,7},{3,5},{3,7}, and {1,3,5}.",
        "inputFormat": " The first line contains three integers: k, N and M, where 1≤k≤N, 1≤N≤20, and 1≤M≤5000000. The second line contains N positive integers; each of them is smaller than 100000.",
        "outputFormat": " The number of ways to pick at least k number out of N positive numbers so that the sum of the picked numbers is no more than M.",
        "sampleInput": [
            "2 4 10\n1 3 5 7\n"
        ],
        "sampleOutput": [
            "6\n"
        ],
        "hint": "",
        "AC": 540,
        "WA": 272
    }
]